-- MySQL dump 10.13  Distrib 8.0.36, for macos14 (arm64)
--
-- Host: 192.168.0.202    Database: linknote
-- ------------------------------------------------------
-- Server version	8.0.39-0ubuntu0.22.04.1

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `action`
--

DROP TABLE IF EXISTS `action`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `action` (
  `id` tinyint NOT NULL AUTO_INCREMENT,
  `name` varchar(50) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `name` (`name`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `action`
--

LOCK TABLES `action` WRITE;
/*!40000 ALTER TABLE `action` DISABLE KEYS */;
INSERT INTO `action` VALUES (1,'ALLOW'),(2,'DENY');
/*!40000 ALTER TABLE `action` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `behavior`
--

DROP TABLE IF EXISTS `behavior`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `behavior` (
  `id` tinyint NOT NULL AUTO_INCREMENT,
  `name` varchar(50) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `name` (`name`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `behavior`
--

LOCK TABLES `behavior` WRITE;
/*!40000 ALTER TABLE `behavior` DISABLE KEYS */;
INSERT INTO `behavior` VALUES (1,'CREATE'),(4,'DELETE'),(2,'READ'),(3,'UPDATE');
/*!40000 ALTER TABLE `behavior` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `invitations`
--

DROP TABLE IF EXISTS `invitations`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `invitations` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `inviterEmail` varchar(50) NOT NULL,
  `inviteeEmail` varchar(50) NOT NULL,
  `notebookId` varchar(34) NOT NULL,
  `message` text,
  `isAccept` tinyint(1) NOT NULL DEFAULT '0',
  `isPending` tinyint(1) NOT NULL DEFAULT '1',
  `date` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `notebookId` (`notebookId`),
  KEY `index_inviterId` (`inviterEmail`),
  KEY `index_inviteeId` (`inviteeEmail`),
  CONSTRAINT `invitations_ibfk_1` FOREIGN KEY (`notebookId`) REFERENCES `notebooks` (`id`) ON DELETE CASCADE,
  CONSTRAINT `invitations_ibfk_2` FOREIGN KEY (`inviterEmail`) REFERENCES `users` (`email`) ON DELETE CASCADE,
  CONSTRAINT `invitations_ibfk_3` FOREIGN KEY (`inviteeEmail`) REFERENCES `users` (`email`) ON DELETE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `invitations`
--

LOCK TABLES `invitations` WRITE;
/*!40000 ALTER TABLE `invitations` DISABLE KEYS */;
INSERT INTO `invitations` VALUES (6,'test@test.com','joey.liao@test.com','NB6bb61275bffb47586a57f94ca21f88a8','來自test的邀請，希望能共同完成LinkNote使用教學筆記！',1,0,'2024-03-12 05:37:43'),(7,'joey.liao@test.com','test@test.com','NB896b68f9bacfc4f4a9cb3c2e349119f7','一起學習Docker吧！',1,0,'2024-03-12 05:43:15'),(8,'joey.liao@test.com','test@test.com','NB141dbe225717cac24196d99b9ebf77b4','',1,0,'2024-03-12 09:18:28');
/*!40000 ALTER TABLE `invitations` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `notebooks`
--

DROP TABLE IF EXISTS `notebooks`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `notebooks` (
  `id` varchar(34) NOT NULL,
  `name` varchar(50) NOT NULL,
  `description` text,
  `status` tinyint(1) DEFAULT '1',
  `userId` varchar(36) NOT NULL,
  `create_date` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `index_userId` (`userId`),
  KEY `index_name` (`name`),
  CONSTRAINT `notebooks_ibfk_1` FOREIGN KEY (`userId`) REFERENCES `users` (`id`) ON DELETE RESTRICT
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `notebooks`
--

LOCK TABLES `notebooks` WRITE;
/*!40000 ALTER TABLE `notebooks` DISABLE KEYS */;
INSERT INTO `notebooks` VALUES ('NB141dbe225717cac24196d99b9ebf77b4','Java','學習Java開發後端API',1,'483d4c98-08a2-47c8-90af-51b7c6a7086d','2024-03-11 06:23:04'),('NB42801eed039177f8620d4c63b3f8acb5','LinkNote API規格','後端Resource & Authentication API規格',1,'userTest','2024-03-12 08:59:59'),('NB6bb61275bffb47586a57f94ca21f88a8','LinkNote使用教學','了解如何使用LinkNote，並透過CODE概念撰寫筆記！',1,'userTest','2024-03-12 05:10:42'),('NB896b68f9bacfc4f4a9cb3c2e349119f7','Docker','學習Docker使用方式，部署應用程式',1,'483d4c98-08a2-47c8-90af-51b7c6a7086d','2024-03-12 05:42:59'),('NBcb38e3739df86de4b7af6edb9821257d','LinkNote開發歷程','LinkNote開發的血汗史',1,'userTest','2024-03-12 07:55:37');
/*!40000 ALTER TABLE `notebooks` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `notebooks_users_role`
--

DROP TABLE IF EXISTS `notebooks_users_role`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `notebooks_users_role` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `notebookId` varchar(34) NOT NULL,
  `userId` varchar(36) NOT NULL,
  `roleId` tinyint NOT NULL,
  PRIMARY KEY (`userId`,`notebookId`),
  UNIQUE KEY `id` (`id`),
  KEY `notebookId` (`notebookId`),
  KEY `roleId` (`roleId`),
  KEY `index_userId` (`userId`),
  CONSTRAINT `notebooks_users_role_ibfk_1` FOREIGN KEY (`notebookId`) REFERENCES `notebooks` (`id`) ON DELETE CASCADE,
  CONSTRAINT `notebooks_users_role_ibfk_2` FOREIGN KEY (`userId`) REFERENCES `users` (`id`) ON DELETE CASCADE,
  CONSTRAINT `notebooks_users_role_ibfk_3` FOREIGN KEY (`roleId`) REFERENCES `role` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=21 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `notebooks_users_role`
--

LOCK TABLES `notebooks_users_role` WRITE;
/*!40000 ALTER TABLE `notebooks_users_role` DISABLE KEYS */;
INSERT INTO `notebooks_users_role` VALUES (9,'NB141dbe225717cac24196d99b9ebf77b4','4336f9d6-e86a-4f15-8fe9-648e22cada83',2),(8,'NB141dbe225717cac24196d99b9ebf77b4','483d4c98-08a2-47c8-90af-51b7c6a7086d',1),(16,'NB6bb61275bffb47586a57f94ca21f88a8','483d4c98-08a2-47c8-90af-51b7c6a7086d',2),(15,'NB896b68f9bacfc4f4a9cb3c2e349119f7','483d4c98-08a2-47c8-90af-51b7c6a7086d',1),(19,'NB141dbe225717cac24196d99b9ebf77b4','userTest',2),(18,'NB42801eed039177f8620d4c63b3f8acb5','userTest',1),(14,'NB6bb61275bffb47586a57f94ca21f88a8','userTest',1),(20,'NB896b68f9bacfc4f4a9cb3c2e349119f7','userTest',2),(17,'NBcb38e3739df86de4b7af6edb9821257d','userTest',1);
/*!40000 ALTER TABLE `notebooks_users_role` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `notes`
--

DROP TABLE IF EXISTS `notes`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `notes` (
  `id` varchar(33) NOT NULL,
  `name` varchar(50) DEFAULT 'new Note',
  `question` text,
  `content` text,
  `keypoint` text,
  `createDate` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  `star` tinyint(1) DEFAULT '0',
  `notebookId` varchar(34) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `index_name` (`name`),
  KEY `index_notebookId` (`notebookId`),
  CONSTRAINT `notes_ibfk_1` FOREIGN KEY (`notebookId`) REFERENCES `notebooks` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `notes`
--

LOCK TABLES `notes` WRITE;
/*!40000 ALTER TABLE `notes` DISABLE KEYS */;
INSERT INTO `notes` VALUES ('N058d42db63d709a872f6969655252694','註解解釋','Spring 註解解釋','# 註解解釋\n\n## Question\nSpring 註解解釋\n\n## 註解解釋\n\n## ***@Component***\n用來將物件交由spring容器管理，並在Dependency Injection時，透過Component關鍵字將實例化的物件也加入spring容器。\n\n## ***@Autowired***\nAutowired用來將Spring容器內的bean實例化給變數。\n一般來說要實例化物件，就需要透過new \"物件\"來建立。但Spring容器中的物件，可以透過加上@Atuowired註解來將Spring容器中的物件自動實例化給變數。\n```java\n@Autowired  \nprivate NamedParameterJdbcTemplate connection;\n```\n這樣寫就能夠自動將NamedParameterJdbcTemplate物件，從容器中找到並且賦予connection變數。\n就不用這樣寫：\n```java\nprivate NamedParmeterJdbcTemplate connection = new NamedParmeterJdbcTemplate();\n```\n## ***@Qualifier*** \n若spring容器中有兩個相同類型的bean，如hpPrinter和canonPrinter都是由Printer interface建立，此時透過autowired建立Printer類型的變數，就會不知道是hpPrinter還是canonPrinter。\n因此建立變數時需要用@Qualifier關鍵字來指定是哪個類型的bean。\n\n      ',NULL,'2024-03-12 09:22:59',0,'NB141dbe225717cac24196d99b9ebf77b4'),('N0b85358b3389c7c9ac0493684d9f8b87','2024-02-09','2024-02-09開發紀錄','# 2024-02-09\n\n## Question\n2024-02-09開發紀錄\n\n## 紀錄\n今天一樣起了個大早，現在時間是8:53，沒有想過我會早起寫code。想一下昨天做到哪了，印象中昨天在處理Interceptor取得url的變數，最後已經可以取得url的變數，並記錄在[[12. Interceptor攔截請求#Interceptor取得Path Variable|Interceptor取得Path Variable]]。\n\n接著就要處理`notebook`, `note`, `tag`, `invitation`, `collaboraotr`的CURD。\n\n先寫出所有基本的Endpoint。\n\n## notebook\n特殊類：因為不需要指定`notebookId`\n- [x] create notebook\n- [x] get 所有notebook\n\n基本類：\n- [x] update指定`notebookId`的筆記本，更新description和名稱。\n- [x] delete指定`notebookId`的筆記本。\n\n## note\n- [x] get所有`notebookId`底下的notes。\n- [x] get指定`noteId`的note。\n- [x] create指定`notebookId`的notes\n- [ ] update指定`noteId`內容\n- [ ] delete指定`noteId`的筆記。\n\n## tag\n- [ ] get指定`notebookId`的tags。\n- [ ] get指定`noteId`的tags。\n- [ ] create指定`notebookId`的tag。\n- [ ] create指定`note`的tag。\n- [ ] delete指定`notebookId`的tag。\n- [ ] delete指定`noteId`的tag。\n\n## invitation\n- [ ] get指定`userId`的invitations(給inviter)。\n- [ ] get指定`userId`的invitations(給invitee)。\n- [ ] create 指定`userId`和`notebookId`的invitation。\n- [ ] update 指定`invitationId`的invitation，用於`允許`或`拒絕`。\n- [ ] delete指定`invitationId`的invitation。\n\n## collaborators\n- [ ] get指定`notebookId`的collaborators。\n- [ ] create指定`notebookId`的collaborators。\n- [ ] delete指定`notebookId`的collaborators。\n\ninvitation和collaborators轉變流程，當user點選確定時，發送`PUT`請求到`/api/initation`並帶上以下參數：\n```json\n{\n	\"invitationId\": Id,\n	\"isAccept\": true\n}\n```\n接著把invitation表中的isOpen變成0(關閉)，並將isAccept改為使用者提交的狀態。\n接著再將notebook_user_role資料表`insert`筆一資料，將`notebookId`, `user`, `roleId`填上。\n## 隨意寫寫\n現在時間3:35，前面吃完午餐後就在耍廢，今天連寫一隻api都還沒，真的有夠廢哈哈哈\n\n\n      ','完成','2024-03-12 08:09:13',0,'NBcb38e3739df86de4b7af6edb9821257d'),('N1244bcf426b7c20fde969c7fbb4495a7','IoC','Spring IoC介紹','# IoC\n\n## Question\nSpring IoC介紹\n\n## IoC反轉控制\n透過spring容器管理自己創立的Object(class)。只需要在class上面加上@component，該class就會被Spring容器管理。未來需要實例化物件時，就不用透過new()建立。\n加上component的class稱為bean。\n\n透過IoC將物件交由Spring容器管理，在透過DI將容器內的object實例化給變數。\n\n\nIoC的精髓在於Polymorphism的特性，在建立bean時，盡量都是用interface建立。\n\n## Qualifier，解決相同類型bean的問題\n若sping容器中有兩個相同類型的bean，如hpPrinter和canonPrinter都是由Printer interface建立，此時透過autowired建立Printer類型的變數，就會不知道是hpPrinter還是canonPrinter。\n因此建立變數時需要用@Qualifier關鍵字來指定是哪個類型的bean。\n\n## Keypoint\n1. Spring IoC的精神在於Polymorphism的特性。\n2. 建立Bean時盡量都使用interface實例化變數。',NULL,'2024-03-12 09:20:28',1,'NB141dbe225717cac24196d99b9ebf77b4'),('N15357547b663b71456b227939348c4b3','2024-02-23 AWS','2024-02-23開發紀錄','# 2024-02-23 AWS\n\n## Question\n2024-02-23開發紀錄\n\n### 紀錄\n今天完成AWS的EC2和RDS的建置，可以參考[[AWS]]筆記。\n\n今天晚上設定好AWS的預算，設定若超過5美金，停止RDS和EC2。\n原本想說直接設定即可，結果卻要一個IAM角色來停止RDS和EC2，結果我在IAM建立一個角色，賦予他EC2和RDS的fullAccess的權限，想說就可以關閉EC2和RDS，但還是無法完成執行動作，結果需要在剛建立的角色中，撰寫信任的設定：\n\n總結一下今天做了啥事，\n1. 建立EC2\n	- 申請SSL憑證\n	- 上傳App\n		- 撰寫外部配置文件\n		- 更改為RDS的ip和mysql帳密\n	- 設定ssh key且撰寫ssh config檔\n	- 安裝應用程式\n		- vim\n		- jre\n		- mysql-client-8.0\n2. 建立RDS\n	- 設定VPC\n	- 建立Database\n	- 將EC2關聯到RDS(需要同一個AZ才不會有額外費用)\n3. 安全群組\n	- 允許EC2連線RDS的政策\n	- LinkNote\n		- 允許80\n		- 允許8080流量\n		- 允許8081流量\n		- 允許ping EC2\n4. 預算設定與動作\n	- 建立IAM角色\n		- EC2 & RDS FullAccess\n		- 建立信任關係\n	- 當當月達到5美金，透過IAM角色停止EC2和RDS\n\n\n明天代辦：\n- [ ] 處理CORS問題，由於Nginx還沒建置，所以要先建立Nginx服務，未來就可以透過Domain來呼叫API，這樣就不會遇到CORS，但是在開發前端時還是需要允許125.229.110.93的CORS，允許從家裏發出API。最好是用Docker來部署Nginx。\n- [ ] 看要不要將app的路徑分為/api/auth和/api/resource開頭，讓Nginx分給相對應的app處理。\n- [ ] 整理出Figma中的所有圖片，丟到S3並建置Cloud Front CDN\n- [ ] 開始撰寫前端頁面\n\n\n## Keypoint\n1. 完成AWS的基礎建置和預算提醒設定',NULL,'2024-03-12 08:17:51',0,'NBcb38e3739df86de4b7af6edb9821257d'),('N1ff01fd502ed41cad3e68b790f751feb','2024-03-03 JS架構','2024-03-03 JS開發紀錄','# 2024-03-03 JS架構\n\n## Question\n2024-03-03 JS開發紀錄\n\n### 紀錄\n# 9:00\n前幾天重構前端JS流程後，再也沒有混亂的感覺，只是有些小問題還得處理，比如刪除或新增筆記本、筆記時，目前刪除後的操作都是reload整個頁面，原因是因為如果刪除或新增NB後，就要更新`Side Bar`那一排Btn和MyNotebooks裡面的noteCtn，如果reload就會直接渲染最新的狀況。\n![](https://github.com/joeyliao127/LinkNote/blob/main/img/demo/2024-03-03-1.png?raw=true)\n\n如圖中若我點了右邊的刪除Java5，那麽側邊欄的Java5筆記也要跟著刪除，但是`Side bar`和`Main`渲染的方式Side Bar發一次request查詢有哪些notebook，再將這些notebookId傳給`Main`渲染出My Notebook的notes。\n\n所以當我刪除後，就要重新渲染這兩塊區域，但是右邊的Main渲染依賴於`Side Bar`的取得的數據，不可能要`Main`叫`Side Bar`重新渲染Notebook Btn，會導致循環依賴的問題。\n\n今天早上太早起床又睡不著，就開始思考前端到底要怎麼解決循環依賴，後來才發現我的前端Javascript架構有嚴重的問題，雖然前幾天重構之後已經變得井然有序，但是依然無法解決刪除、新增、更新狀態後的問題，說也神奇，眼睛閉上思考問題一下就有解了，我發現問題是出自於**沒有統一的資料來源**。\n\n目前Main渲染出的筆記本都是來自於`Side Bar`中顯示的筆記本有多少，但`Main`不該依賴`Side Bar`的筆記本，而是`Side Bar`和`Main`都要依賴相同的來源，也就是透過第三方物件來控制這兩個Class。\n\n具體做法為建立一個新的Class暫時叫做`Attributes`，並將`Side Bar`和`Main`透過new成為`Attributes`的私有屬性。但是在new之前，`Attributes`必須要先Fetch到後端取得Notebooks，將取得到的notebooks儲存到Class的私有屬性，而這個私有屬性就是`Side Bar`和`Main`的共同來源資料，接著就可以new `Side Bar`和`Main`將notebook渲染到畫面上，每當`main`中有新增、刪除、更新notebooks的情況，`Side Bar`就要重新渲染該區域。\n\n至於要如何實現**main新增、刪除、更新notebook就重新渲染Side Bar**，閉上眼睛一想就想到Java的getter和setter，也就是說`Main`更新notebook的狀態後，就會呼叫`Attributes`的setter來更新notebooks，而後就可以呼叫Side Bar render來重新渲染，並且是使用`Main`更新`Attributes`後的notebook，這樣就解決了重新渲染的問題。\n\n但是這樣還是有些問題，就是`side bar`的notebook btn有兩種，一種是my notebook，另一種是coNotebook，那麼要渲染哪一個區塊，就要知道當前有哪一塊是顯示在畫面上，所以`Attribute`又要新增一個屬性來紀錄當前顯示的區塊是哪一個。\n```js\ndisplayBlock = {\n	\"myNotebook\": true,\n	\"coNotebook\": false,\n	\"Invitation\": false,\n	\"setting\": false\n}\n```\n\n至於要怎麼紀錄，一開始的想法是重新渲染完哪個區塊，就修改`Attributes`的`displayBlock`，但`side bar`依賴於`Attributes`，所以不可能是透過`side bar`修改狀態，所以我想到的方法是render完`Side bar`某一個block後，就return boolean，紀錄當前`side bar`中渲染的是哪個區塊，這樣就解決了要渲染哪一塊的問題。\n\n然後我又進階想下去，想到其他地方也會有類似的問題，這時才發現原來整個架構都要改。\n\n![](https://github.com/joeyliao127/LinkNote/blob/main/img/demo/2024-03-03-2.png?raw=true)\n\n比如上面這張圖，這是筆記撰寫頁面，左邊`Side Bar`有透過tag篩選出有指定tag的notes，右邊的tag是將筆記加上note，但是這兩個tag又都有remove\n\n\n明天從setFilter開始做起，每當setFilter被呼叫時就要重新渲染noteCardCtn，代表有新的參數加入。\n至於點選側邊欄是否要resetFilter，目前覺得可能需要，因為有分Notebooks和notebook兩種Side Bar btn， 因此需要根據不同的餐數渲染noteCardCtn。\n\n總之明天從setFilter開始做，點選tool bar中的filter就render NoteCardCtn，若點選allbox還要領外思考怎麼實現\n\n      ',NULL,'2024-03-12 08:54:39',1,'NBcb38e3739df86de4b7af6edb9821257d'),('N2471e896a68756d1a6ec59249f6de5a4','Docker基本指令','Docker指令大全。','# Docker基本指令\n\n## Question\nDocker指令大全。\n\n## 一般指令\n***版本：***\n```\ndocker version\n```\n\n\n## 容器基本操作\ndocker + 管理的物件（例如容器，映像） + 具體操作（例如創建，啟動，停止，刪除）\n\n##### 拉取一個叫nginx的docker image映像\n```\ndocker image pull nginx\n```\n\n##### 停止一個叫web的docker container容器\n```\ndocker container stop web\n```\n\n#### run Container\n##### 創建容器：指定image並運行container。(後為簡化版)\n```\ndocker container run <image name>\ndocker run <image name>\n```\n\n##### docker container port映射\n```\ndocker container run -p 本機端口:容器端口 image名稱\n```\n透過`-p`參數來將本機和容器端口對應。\n\nex.\n```\ndocker container run -p 80:8080 Spring-boot-resource\n```\n當使用者訪問本機的80端口，就會被容器的8080端口接收。\n###### attach模式\n- 透過這種方式創建容器的話，容器在前台執行\n- 容器的輸入輸出結果會反映在本地端，本地端的輸入輸出也會反映到容器，例如能在終端機看到網頁瀏覽器的log，ctrl + c 會讓容器停止執行\n- 一般情況不建議使用\n```\ndocker container run -p 80:80 nginx\n```\n###### detach模式\n- 容器會在背景執行\n```\ndocker container run -d -p 80:80 nginx\n```\n\n##### 列出*運行中*的容器：\n```\ndocker container ls\ndocker ps\n```\n\n\n##### 列出*運行中與停止*的容器：\n```\ndocker container ls -a\n```\n\n\n##### 批量停止容器\n\n方法1：\n```\ndocker container stop cd3 269 34b 751\n```\n\n##### 批量刪除容器和image\n刪除所有停止的容器\n```\ndocker system prune -f\n```\n刪除所有沒有用到的image\n```\ndocker system prune -a\n```\n兩個沒有用到的一起清\n```\ndocker system prune -a -f\n```\n\n\n#### 連接容器的shell\n##### 創建container並且進入shell\n```\ndocker container run -it busybox sh\n```\n`docker container run -it` +` image名稱` + `sh`\n##### 進入運行中container的shell\n```\ndocker container exec -it 33d sh\n```\n`docker container exec -it` + `容器的Hash值` + `sh`\n\n\n\n## Image基本操作\n```\n$ docker image\n\nUsage:  docker image COMMAND\n\nManage images\n\nCommands:\nbuild       Build an image from a Dockerfile\nhistory     Show the history of an image\nimport      Import the contents from a tarball to create a filesystem image\ninspect     Display detailed information on one or more images\nload        Load an image from a tar archive or STDIN\nls          List images\nprune       Remove unused images\npull        Pull an image or a repository from a registry\npush        Push an image or a repository to a registry\nrm          Remove one or more images\nsave        Save one or more images to a tar archive (streamed to STDOUT by default)\ntag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE\n\nRun \'docker image COMMAND --help\' for more information on a command.\n```\n以上是image的所有動作，有空可以研究，這邊只說明幾個常用的。\n\n#### Pull Image\n從docker hub取得image\n```\ndocker pull nginx\n```\n拉取指定版本\n```\ndocker pull nginx:1.20.0\n```\n#### 查看image\n```\ndocker image ls\n```\n#### 刪除image\n```\ndocker image rm sha值\n```\n\n#### image導入和導出(offline)\n##### 導出\n```\ndocker image save `image名稱` -o `儲存的image名稱`\n```\n-o 參數：代表輸出成一個文件，副檔名要叫俄麽都可以，課程中是寫nginx.image。\n##### 導入\n```\ndocker image load -i `image名稱`\n```\n\n範例：\n```\nPS C:\\Users\\Peng Xiao\\docker.tips\\image> docker image ls\nnginx        1.20.0    7ab27dbbfbdf   12 days ago   133MB\nnginx        latest    f0b8a9a54136   12 days ago   133MB\nPS C:\\Users\\Peng Xiao\\docker.tips\\image> docker image save nginx:1.20.0 -o nginx.image\nPS C:\\Users\\Peng Xiao\\docker.tips\\image> ls\n\n\n    Directory: C:\\Users\\Peng Xiao\\docker.tips\\image\n\n\nMode                 LastWriteTime         Length Name\n----                 -------------         ------ ----\n-a----         5/24/2021   1:40 PM      137379328 nginx.image\n\n\nPS C:\\Users\\Peng Xiao\\docker.tips\\image> docker image rm 7ab\nUntagged: nginx:1.20.0\nDeleted: sha256:7ab27dbbfbdf4031f0603a4b597cc43031ff883b54f9329f0309c80952dda6f5\nDeleted: sha256:5b2a9404d052ae4205f6139190fd4b0921ddeff17bf2aaf4ee97f79e1a8242fe\nDeleted: sha256:03ebf76f0cbf5fd32ca010bb589c2139ce7e44c050fe3de2d77addf4cfd25866\nDeleted: sha256:0191669d087dce47072254a93fe55cbedd687f27d3798e2260f846e8f8f5729a\nDeleted: sha256:17651c6a0ba04d31da14ac6a86d8fb3f600883f9e155558e8aad0b94aa6540a2\nDeleted: sha256:5a673ff4c07a1b606f2ad1fc53697c99c45b0675734ca945e3bb2bd80f43feb8\nPS C:\\Users\\Peng Xiao\\docker.tips\\image> docker image ls\nREPOSITORY   TAG       IMAGE ID       CREATED       SIZE\nnginx        latest    f0b8a9a54136   12 days ago   133MB\nPS C:\\Users\\Peng Xiao\\docker.tips\\image> docker image load -i .\\nginx.image\n1839f9962bd8: Loading layer [==================================================>]   64.8MB/64.8MB\na2f4f809e04e: Loading layer [==================================================>]  3.072kB/3.072kB\n9b63e6289fbe: Loading layer [==================================================>]  4.096kB/4.096kB\nf7141923aaa3: Loading layer [==================================================>]  3.584kB/3.584kB\n272bc57d3405: Loading layer [==================================================>]  7.168kB/7.168kB\nLoaded image: nginx:1.20.0\nPS C:\\Users\\Peng Xiao\\docker.tips\\image> docker image ls\nREPOSITORY   TAG       IMAGE ID       CREATED       SIZE\nnginx        1.20.0    7ab27dbbfbdf   12 days ago   133MB\nnginx        latest    f0b8a9a54136   12 days ago   133MB\nPS C:\\Users\\Peng Xiao\\docker.tips\\image>\n```\n\n\n\n#### 透過docker file建立image\n1. 建立一個叫做Dockerfile的文件，不需要副檔名，Dockerfile的撰寫請參考[[4. Dockerfile|Dockerfile筆記]]\n2. app(如jar檔)和Dockerfile需要放在同一個資料夾 。\n3. 透過`docker image build -t \"image名稱\" \"儲存位置\"。\n\nEx.\n```\ndocker image build -t Resource .\n```\n指定dockerfile路徑，無需和Dockerfile在同個目錄也能使用該Dockerfile\n```\ndocker image build -f ../Dockerfile-env -t Resource\n```\n-t：代表image名稱。\n透過Dockerfile將app打包成docker image，名稱為Resource，並且儲存在當前資料夾。\n\n#### push到Docker hub\n1. 登入docker hub\n```\ndocker login\n```\n輸入帳密即可。\n2. psuh\n```\ndocker image push joeyliao/resource1.0\n```\n若想push自己建立的docker image，就必須在image名稱前面加上DockerHub註冊的使用者id(帳號)，並加上版本。\n\n\n## Docker網路相關指令\n### Linux網路相關指令\n#### 查看ip\n```\nifconfig\n```\n或是\n```\nip a\n```\n![[Pasted image 20240225092127.png]]\neth0和docker0是最重要的兩個資訊。\n\n#### 測試port是否開啟\n```\ntelnet www.baidu.com 80\n```\n\n#### 探測請求路徑\n```\ntracepath\n```\n可以查找發送請求經過的所有設備的(如果沒有隱藏)\n\n#### 下載Server回應的HTML等文件\n```\ncurl https://linknote.online\n```\n這個curl指令不只可以將HTML結果抓回，還有許多強大的功能。\n更多用法可以參考：[curl使用方法](https://www.ruanyifeng.com/blog/2019/09/curl-reference.html)\n\n### Docker網路指令\n#### 查看Docker container的ip和其他資訊\n```\ndocker container inspect 容器名稱\n```\n![[Pasted image 20240225094408.png]]\n#### container端口轉發\n```\ndocker container run -p 80:8080 Spring-boot-resource\n```\n透過`-p`參數就可以將\"**宿主機端口**\"轉換為\"**contianer端口**\"。\n\n#### 查看docker network\n```\ndocker network ls\n```\n\n可以搭配`inspect`來查看，後面加上橋接器的sha值就可以看到細節。\n```\ndocker network inspect sha值\n```\n\n筆記大多源自：[Udemy講師 Peng Xiao](https://dockertips.readthedocs.io/en/latest/)\n\n\n\n      ',NULL,'2024-03-12 09:32:21',1,'NB896b68f9bacfc4f4a9cb3c2e349119f7'),('N47b2fc5df4ff934db8aa15cb45f73fd8','取得前端傳遞的參數','如何取得前端傳來的參數？','# 取得前端傳遞的參數\n\n## Question\n如何取得前端傳來的參數？\n\n\n# 簡介\n共分為四種方式取得參數：\n- @RequestParam\n- @RequestBody\n- @RequestHeader\n- @PathVarible\n\n## @RequestParam 取得GET方法的參數\n也就是取得http://localhost/?後面的參數。\n![[Pasted image 20231005184233.png|400]]\n在route底下的Fn參數中，加上@RequestParam並宣告GET方法傳來的參數Data type。\n\n\n傳遞多個參數：每個參數前都要加上@RequestParam\n```java\n@RequestMapping(\"/getParam\")  \npublic String getParam(@RequestParam int id,  \n                       @RequestParam String name  \n                       ){  \n    return \"取得的id：\" + id + \"\\n取得的name：\"+name;  \n}\n```\n\n### @RequestParam()帶參數\n#### required = False\n加上required = False，代表參數可有可無。\n```java\npublic String getParam(@RequestParam(required=False) int id, @RequestParam String name){  \n    return \"取得的id：\" + id + \"\\n取得的name：\"+name;  \n}\n```\n\n#### default = \"10\"\n若請求沒有包含此參數，則用default值。\n```java\npublic String getParam(@RequestParam(defalut=10) int id, @RequestParam String name){  \n    return \"取得的id：\" + id + \"\\n取得的name：\"+name;  \n}\n```\n\n\n## @RequestBody 取得Post method 中request body的參數\n一共有兩個步驟：\n1. 建立一個class，用來對應request body中的json key & value。\n2. 在route底下的Fn的輸入參數中加上@RequestBody註解，並且宣告Fn的輸入參數類別為上面class自定義的類別\n3. 透過getter取得request傳遞的value。\n\n假設request會傳來name, age, phone並且都是String。\n自定義class內容：\n```java\npackage com.example.demo;  \n  \npublic class getBodyData {  \n    private String name;  \n    private String age;  \n    private String phone;  \n  \n    public String getName() {  \n        return name;  \n    }  \n  \n    public void setName(String name) {  \n        this.name = name;  \n    }  \n  \n    public String getAge() {  \n        return age;  \n    }  \n  \n    public void setAge(String age) {  \n        this.age = age;  \n    }  \n  \n    public String getPhone() {  \n        return phone;  \n    }  \n  \n    public void setPhone(String phone) {  \n        this.phone = phone;  \n    }  \n}\n```\n\nRoute內容：\n1. 宣告參數類別為getBodyData，並命名為data。\n2. 回傳List格式的物件\n3. 透過getter方法取得內容。\n```java\n@RequestMapping(\"/postTest\")  \npublic List<String> getBodyParam(@RequestBody getBodyData data){  \n    List info = new ArrayList<String>();  \n    info.add(data.getName());  \n    info.add(data.getAge());  \n    info.add(data.getPhone());  \n    return info;  \n}\n```\n\n\n### 複雜格式的參數\n```json\n{\n\n	\"name\": \"python\",	\n	\"tags\":[\"a1\", \"a2\", \"a3\"],	\n	\"description\": \"test\",	\n	\"emails\":[\"a1@example.com\", \"a1@example.com\",\"a1@example.com\",\"a1@example.com\",\"a1@example.com\"],	\n	\"info\": {\n		\"namelist\":[1, 2, 3, 4]	\n	}\n}\n```\n\n在DTO的部分，主要是透過class中定義class來宣告物件。\n比如info物件，就要宣告一個Info類型的Info物件。\n可以定義在class中，並且設定getter和setter。\n```java\npackage com.linknote.online.linknotespring.note.notedto;  \n  \nimport jakarta.validation.Valid;  \nimport jakarta.validation.constraints.NotBlank;  \nimport java.util.List;  \n  \n@Valid  \npublic class NotebookCreateParamsDTO {  \n  @NotBlank  \n  private String name;  \n  \n  private List<String> tags;  \n  private String description;  \n  \n  private List<String> emails;  \n  private Info info;  \n  \n  public static  class Info{  \n    private List<Integer> namelist;  \n  \n  \n    public List<Integer> getNamelist() {  \n      return namelist;  \n    }  \n  \n    public void setNamelist(List<Integer> namelist) {  \n      this.namelist = namelist;  \n    }  \n  }  \n  public Object getInfo() {  \n    return info;  \n  }  \n  \n  public void setInfo(Info info) {  \n    this.info = info;  \n  }  \n  \n  public String getName() {  \n    return name;  \n  }  \n  \n  public void setName(String name) {  \n    this.name = name;  \n  }  \n  \n  public List<String> getTags() {  \n    return tags;  \n  }  \n  \n  public void setTags(List<String> tags) {  \n    this.tags = tags;  \n  }  \n  \n  public String getDescription() {  \n    return description;  \n  }  \n  \n  public void setDescription(String description) {  \n    this.description = description;  \n  }  \n  \n  public List<String> getEmails() {  \n    return emails;  \n  }  \n  \n  public void setEmails(List<String> emails) {  \n    this.emails = emails;  \n  }  \n}\n\n```\n\n取得Info類型物件底下的namelist中的index = 1的數值。\n```java\nparams.getInfo().getNamelist().get(0)\n```\n## @RequestHeader 取得header內容\n一樣加在route底下的Fn，並且加上@RequestHeader註解，下面的例子有兩個。\n第一個例子是，***宣告String加上變數名稱用來接住header中的key。***\n第二個例子是用來指定name=\"Content-Type\"的key，要傳遞給ContentType變數。 \n```java\n@RequestMapping(\"/getAuthorization\")  \npublic String getAuthorization(@RequestHeader String Authorization){  \n    return Authorization;  \n}\n\n@RequestMapping(\"/getHeader\")  \npublic String getHeader(@RequestHeader(name=\"Content-Type\") String ContentType){  \n    return ContentType;  \n}  \n```\n\n@RequestHeader也可以加上required參數來要求header中一定要包含指定內容，如指定一定要Authorization參數等。\n```java\n@RequestMapping(\"/getHeader\")  \npublic String getHeader(\n	@RequestHeader(name=\"Content-Type\") String ContentType,  \n	@RequestHeader(required =true) String Authorization){  \n	    return ContentType;  \n}\n```\n\n@RequestHeader也可以用defaultvalue，\n```java\n@RequestMapping(\"/getHeader\")  \npublic String getHeader(\n	@RequestHeader(name=\"Content-Type\", defaultValue = \"application/json\") String ContentType,  \n    @RequestHeader(required =true) String Authorization){  \n    return ContentType;  \n}\n```\n\n\n## @PathVariable 取得URL中的值\n注意{value}中的值需要和@PathVariable裡面的變數名稱要一致。\n```java\n@RequestMapping(\"/getURLValue/{id}\")  \npublic Integer getURLValue(@PathVariable Integer id){  \n    return id;  \n}\n```\n\n取得多個參數：\n```java\n@RequestMapping(\"/getURLValue/{id}/{name}\")  \npublic String getURLValue(@PathVariable Integer id, @PathVariable String name){  \n    return \"ID = \"+ id + \"Name = \"+ name;  \n} \n```\n## Keypoint\n共有四種類型的前端參數可以取得：\n- Header\n- Path Variable\n- Param\n- Request Body\n\n      ','共有四種類型的前端參數可以取得：','2024-03-12 09:25:11',1,'NB141dbe225717cac24196d99b9ebf77b4'),('N594ecafac0ce152eba602b68219d9cec','2024-02-16後端心得','2024-02-16開發紀錄','# 2024-02-16\n\n## Question\n2024-02-16開發紀錄\n\n### 紀錄\n昨天終於把後端做完了QQ，還寫好了API文件，感覺真的是不錯，接下來要想一下前端要如何規劃，我在做專案的時候發現**想清楚**在做比直接做還要好上很多很多很多，雖然在規劃時會覺得都沒有進度，但從全局的視角思考程式碼如何撰寫，可以更有條有理的寫好一整個專案，讓整個專案的每一個部分，都按照相同的**邏輯**或**習慣**去開發，就可以避免程式碼混亂的情況發生，讀完Clean code真的讓我進步了很多，該抽象的抽象，該拆分到其他method的code就拆分，整個專案井然有序，就像一個藝術品一樣。\n\n舉一個簡單的例子，在專案中幾乎所有的Controller收到請求後，都會有一個`xxxRequestPo`這樣的物件來傳遞參數到DAO層，而回傳資料時，在Service層都有一個`xxxResponsePo`，將DAO查出的DTO set到`xxxResponsePo`，整個專案都按照這個習慣做開發，因此沒有什麼特別混亂或看不懂的物件，方法也是該拆就拆，未來再新增或修改專案時，也能夠輕易讀懂程式碼，因為都是按照一樣的規律撰寫。\n\n剛才說到**想清楚**比直接做還要好，這邊也舉一個例子，如果直接做的話會想notebook需要返回哪些資料，然後把notebookId, name, description, tags, owner, collaborator通通寫在一個notebook三層式架構中，這也是為什麼LinkNote1.0失敗的地方，因為沒有想清楚就直接做了，因此notebook三層式架構錯綜復雜，一下notebook service DI了tagDAO，一下又DI tokenService，一堆奇奇怪怪的程式交織再一起。\n\n但想清楚是怎麼回事後，不難發現整個專案就只有七大區塊。\n- User相關\n- 權限相關\n- notebook CRUD\n- note CRUD\n- tag CRUD\n- invitation CRUD\n- collaborator CRUD\n\n因此只要完成這六點的CRUD，基本上專案都可以保持井然有序，tagService不會寫在notebook三層式架構，而是新增tag三層式架構，有許要調用tag，就注入TagService或DAO，也因此將User和權限寫成一個App，其餘的都寫在Resource，這樣就是從更廣闊的視角拆分工作，有點像一個Function只做一件事情，只是為度更高了一點。\n\n還有就是在寫API時可以想想前端怎麼call會比較方便，又可能會需要哪些資料，這些除了PM會決定，但身為工程師會有工程師的視角，多思考也許可以提出更好的方案，或避免一些潛在問題。\n\n接下來要繼續寫前端了，但難免有些擔心會忘記寫後端的感覺和思考模式，因此今天詳細了紀錄開發過程中我認為最重要的事情。\n\n除了以上想法，還可以多利用Enum和多態的特性來思考如何運用在程式碼中。\n\n## Keypoint\n1. 想清楚比直接做重要\n2. 有邏輯的開發讓專案井然有序\n      ',NULL,'2024-03-12 08:15:15',1,'NBcb38e3739df86de4b7af6edb9821257d'),('N59d395b26a9458a2ec0139a5cb44e8a6','2024-02-12','2024-02-12開發紀錄','# 2024-02-12\n\n## Question\n2024-02-12開發紀錄\n\n## 紀錄\n現在時間下午四點，剛寫完[[2024-02-12 大年初三]]的日記，現在該來規劃等等要完成的事情。\n從昨天晚上到剛剛都在做note, tag, invitation, collaborator的三層式架構，等等開始思考note的CRUD有哪些需要注意的地方，由於存取的部分已經全權交由Authentication Server，因此只需要專注在使用者要如何call API比較容易和撰寫正確的sql即可。\n\n有幾點需要特別處理的：\n1. 新增共編人員流程，該如何透過invitation表和notebooks_users_role來搭配新增collaborator。\n2. 記得要寫中介表！！\n\n希望今天可以做完note相關！！\n\n\n      ',NULL,'2024-03-12 08:11:01',0,'NBcb38e3739df86de4b7af6edb9821257d'),('N5ace17699f90f2bca2b4b2966bb089e6','2024-02-02','2024-02-02的開發紀錄','# 2024-02-02開發紀錄\n## Question\n2024-02-02的開發紀錄\n## 權限管理\n權限管理設計是一個很複雜的事情，我想了兩天終於想出最佳解。\n\n基本操作：只需要知道`user`對於`notebook`的`role`即可操作。\n因此auth Server在查詢時只要知道以下幾點資訊：\n1. userId\n2. notebookId (搭配userId取得role)\n3. action\n![ERD](https://github.com/joeyliao127/LinkNote/blob/main/img/LinkNote-ERD.png?raw=true)\n這個`role_permission`紀錄了`role`可以做的事情。\n### 可擴展性\n由於這張表符合第三正規劃，因此要擴展就非常方便，在後端要擴展也是。\n \n#### 擴展資料表\n先說資料表擴展，比如想新增一個`Action`，指需要insert一筆資料即可，再將新增的`Action`記錄到哪些`Role`即可完成`Action`的擴展，或者是突然想新增一個`Role`，比如說目前還沒打算做的`Guest`，新增一個`Guest`角色，並且在`role_permission`記錄`Guest`可以做的事情即可，未來也可以考慮新增留言或是按讚等功能。\n\n#### 後端擴展\n目前後端驗證Request是否可以取得資源，可以參考[[1. Application架構說明]]筆記，由於取得資源和授權兩個App是分開的，因此未來要擴展也很容易。\n\n至於`auth` controller的驗證也很容易擴展，因為目前的驗證方式都是透過`取得資源` App 的攔截器發出請求給`auth` APP，根據不同的Target來發送驗證，因此未來若要新增\"**是否可以查看留言**\"或是\"**是否可以按讚**\"等權限，就直接在Auth的Controller中新增一個endpoint，用來檢查\"**是否可以查看留言**\"或是\"**是否可以按讚**\"。\n\n## 繼承和多態\n今天居然用到繼承和多態！！！\n今天為了要寫一個method，而用到這兩個OOP的特性。\n\n有一個method要放入`request`物件，而這個物件有可能是notebookPermissionRequest, notePermissionRequest, tagPermissionRequest, collaboratorPermissionRequest其中之一，那時候就在想**我的param要怎麼寫才能夠讓四種類型的變數都能用？**\n而這四個物件都有基本的五個屬性：\n```java\n@NotBlank  \nprivate String email;  \n  \n@NotNull  \nprivate Integer notebookId;  \n  \n@NotNull  \nprivate Action action;  \n  \nprivate Target target;  \n  \nprivate String token;\n```\n\n因此我就建立一個class叫做PermissionRequest，宣告這五個屬性，並且讓notebookPermissionRequest, notePermissionRequest, tagPermissionRequest, collaboratorPermissionRequest都繼承這個class。\n\n建立method時就可以宣告輸入參數為PermissionRequest，根據多態的特性，繼承了PermissionRequest的四個Request都可以當作參數放入。\n\n範例：\n```java\nprivate PermissionRequest userIdentify(PermissionRequest request){  \n  String token = request.getToken();  \n  if (token.isEmpty()){  \n	  ...\n  }  \n  return request;  \n}\n```\n\n其實抽象和繼承，我覺得就只是傳遞的概念不同而已。\n比如說繼承是傳遞了具體的方法或屬性，把他傳給下一個class。\n但是抽象就只是先傳遞給Class抽象方法中定義的method，並記得要實作。\n所以繼承是傳遞\"**實體的屬性或方法**\"，抽象則是傳遞\"**一個概念**\"。\n\n## Enum類型實戰\n今天也用到了Enum，覺得很神奇，用在定義`Role`, `Permission`, `Target`, `Action`，這樣就不會出錯了，也不用記在腦中`Role`有哪些角色、`Action`有哪些動作，而且method還可以回傳Enum類型的變數！！\n\n## Keypoint\n1. 規劃好RBAC權限管理模型資料表，並且考量到日後擴展所需。\n2. 使用到OOP的繼承和多態，第一次使用Enum類型。\n      ','主要ㄐㄧ','2024-03-12 07:56:01',0,'NBcb38e3739df86de4b7af6edb9821257d'),('N60a8bbfa2ba29152b29bdda57586d2df','2024-02-08','2024-02-08開發紀錄','# 2024-02-08\n\n## Question\n2024-02-08開發紀錄\n\n## 紀錄\n今天是小年夜，一大早就回雲林，昨天也沒寫code，一整個忘記要幹嘛。\n印象中上次上次正在做resource攔截器的部分，還要處理Notebook權限的部分，因為筆記本有分對**單一**和對**全部**筆記本的區別，這兩種類型的請求，對於請求參數有差，因此正在思考如何解決。\n\n比如GET所有筆記本，請求參數就不需要上notebookId，但是請求指定notebookId就要加上notebookId參數。\n但所有的驗證請求中，只有GET所有notebook才會這樣，沒有所謂的UPDATE all notebook或CREATE all notebook等等奇怪的行為，還是說如果是CREATE操作，丟給User攔截器即可，這個好像可以！！\n\n\n      ','沒啥重點','2024-03-12 08:07:35',0,'NBcb38e3739df86de4b7af6edb9821257d'),('N6272f2e986a0007b4bd4c06d49e510bd','2024-02-25','2024-02-25開發紀錄','# 2024-02-25 Docker\n\n## Question\n2024-02-25開發紀錄\n\n### 紀錄\n今天也在學習Docker，已經了解Docker的網路是透過Bridge完成，接著透過NAT讓container能連上公網，但目前有一個問題是Docker如何連接到Mac的Mysql。\n\n所以今天的任務是：\n- [x] 研究如何連上Mac的MySQL\n- [x] 研究Nginx配置引入＆引入SSL憑證到container中的Nginx\n- [ ] 將網站的圖片上傳到S3透過CloudFront CDN做Cache。\n- [x] 健身！！！\n\n      ',NULL,'2024-03-12 08:29:41',0,'NBcb38e3739df86de4b7af6edb9821257d'),('N653c7b8c66db2512042b91bb2312e975','2024-02-26 CORS','2024-02-26開發紀錄','# 2024-02-26 CORS\n\n## Question\n2024-02-26開發紀錄\n\n### 紀錄\n#### 9:00\n延續昨天未完成的事項：\n- [x] CloudFront CDN\n	- [x] 在Figma下載使用到的圖片\n	- [x] 上傳到S3\n	- [x] 部署CloudFront CDN\n\n今日待辦事項：\n- [ ] 前端頁面\n	- [ ] `/notebooks`的side bar。\n	- [ ] 新建Notebook\n\n昨天透過Docker將App都運行起來，看起來蠻順利的，只剩下Docker的Nginx和SSL憑證的申請。\n可以參考[[在Docker Nginx容器申請Let\'s encrypt]]，已經紀錄在[[3. Linknote待辦事項]]筆記中。\n\n今天打算先把網站會用到的圖片上傳到CDN，接著開始刻前端。\n\n#### 14:30\n[[7. Cloud Front|Cloud Front]]的建置比想像中還要快上許多，下午就可以開始刻前端！！\n\n#### 19:00\n今天這個有得紀錄了，如果不熟悉CORS、網路架構、加上腦袋不清楚、加上若沒在Spring寫log，這個Debug可能會搞到隔天。\n\n問題：先說，這只是在開發環境會遇到的，因為有跨域問題\n\n今天透過Mac的Intellj啟動Resource，因為template寫在Resource，運行在8081。\n\n由於Docker Nginx 已經設定好/api/notebooks的proxy，設定為`172.17.0.1:8081`，也就是Bridge的ip，想說Docker能透過內部網路連到Mac的Resource，結果發現連不上，所以就想說在Docker內直接把Resource服務跑起來，這樣Nginx收到`/api/notebooks`的請求就會轉送到Docker Resource，取得notebook等資源。\n\n所以Nginx就要設定，當接收到`/api/notebooks`的請求時，轉送到`172.17.0.5:8081`，也就是透過Docker跑起來的Resource，內部聯繫一定可以通，但會出現一個問題，那就是我在開發前端時，寫完一段前端頁面都要重跑Intellj，檢查樣式有沒有問題之類的，所以Intellj的port會卡到Docker Resource的8081，所以就透過配置文件先暫時跑在8082。\n\n到這邊差不多就可以透過`http://localhost`來取得Linknote的首頁，因為會代理到8081取得首頁，但是還是有一個問題，那就是CROS會阻止我訪問`localhost`，原因是Intellj的Resource運行在8082，向`localhost`請求`/api/notebooks`屬於跨域，因此需要在Nginx的`/api/user`, `/api/notebooks`, `/api/coNotebooks`, `/api/auth`, `/api/invitation`等等的location，全都加上CORS設定。\n\n最後終於解決開發環境請求的問題。\n\n實際操作：\n1. Nginx在location設定CORS\n2. 在Spring Boot Resource將驗證的Path，從localhost:8080改為從外部文件透過[[1. IoC解析@Valeu(\"${key}指定Authentication Server的路徑。\n3. 重新建立Docker image，並將Resource外部配置文件中的authenticationServer變數，改為Docker Authentication app的ip。\n4. 完成！\n\n\n\n\n## Keypoint\n      ',NULL,'2024-03-12 08:30:27',1,'NBcb38e3739df86de4b7af6edb9821257d'),('N69ab03ee0a86b688e0e8cba57b917b47','2024-03-06','2024-03-06開發紀錄','# 2024-03-06\n\n## Question\n2024-03-06開發紀錄\n\n### 紀錄\n好幾天沒有寫開發紀錄了，昨天終於把最難搞的筆記本管理介面處理好，基本上都沒有太大的問題，還蠻滿意的，昨天晚上也把筆記本撰寫頁面也刻好，快的話今天就能完成整個專案，然後部署到AWS，由於note頁面是全新的頁面，因此我想好好的思考渲染流程，雖然說notebook頁面的JS有點在亂用class，但是整個渲染是井然有序的，我能很快速的找到我想修改的區域，應該算是還行吧！現在想想有一個project可以部署、練習寫測試等等，就覺得還蠻好的，而且這個專案會讓我想持續優化，未來想練習資料庫叢集或是練習React，都可以用LinkNote做修改，而且有Docker和Git可以無限制的重複修改也不會怎樣。\n\n現在我閉上眼睛思考，到底要如何實作筆記撰寫頁面。\n\nConstructor：\n1. 使用者會從notebook點擊noteCard，將url變成帶有notebook和noteId的url，因此建構函示就需要先取得url中的notebook和note的ID。\n2. 透過notebook取得notes資料，設定到Class的私有變數，共用同一個變數的區域有：\n	- SideBar - note, tag\n	- TopBar - note的 tag\n3. 有了notes就可以渲染SideBar\n	- SideBar的noteCtn要根據filter渲染筆記\n	 - userInfo設定\n4. 渲染topBar\n	- Tags\n	- collaborators\n5. 取得noteContent(Content, tags)\n6. 渲染到topBar的tag和new一個tui.editor，將content傳入。\n7. 開始一秒儲存一次內容。\n\n\n待辦清單：\n- [x] 更改tagCtn和FilterCtn的z-index\n- [x] 新增Filter和Tag Btn的點擊事件，點擊後關閉另一個。\n- [x] noteBtn改為a標籤。\n- [x] 透過filter渲染noteBtn\n\n\n      ',NULL,'2024-03-12 09:01:10',0,'NBcb38e3739df86de4b7af6edb9821257d'),('N7bbd4f2ed3f66eaf90c2ff1bb8cd5191','Spring回傳JSON','Spring Boot如何回傳JSON？','# Spring Boot回傳JSON\n\n## Question\nSpring Boot如何回傳JSON？\n\n## 回傳JSON\n\n直接return自定義的實例化物件即可。Spring就會自動找到Class中的變數，將變數名稱和變數數值建立成JSON的Key和Value。\n\n當@RequestMapping所套用的方法的return類型是自定義的method時，就會自動將內容轉換為JSON格式。然後將return的值放到response.body裡面。\n\n先建立一個Student class\n```java\npublic class Student {  \n    String name;  \n  \n    public String getName() {  \n        return name;  \n    }  \n  \n    public void setName(String name) {  \n        this.name = name;  \n    }  \n}\n```\n建立Controller，並實例化Student:\n```java\n@RequestMapping(\"/user\")  \npublic Student user(){  \n    Student student =new Student();  \n    student.setName(\"Joey\");  \n    return student;  \n}\n```\n\n回傳結果：\n```json\n{\n	\"name\": \"Joey\",\n}\n```\n\n若要回傳較為複雜的JSON資料如下\n```json\n{ \"data\": { \n	\"number\": \"B1696393420\",\n	 \"price\": 2000,\n	  \"trip\": { \n		\"attraction\": {\n				\"id\": 11,\n				\"name\": \"艋舺龍山寺\",\n				\"address\": \"臺北市 萬華區廣州街211號\"\n			},\n			\"date\": \"2023-10-18\",\n			\"time\": \"morning\" \n		},\n		\"contact\": {\n			\"name\": \"aaa\",\n			\"email\": \"aaa@aqua.com\",\n			\"phone\": \"0912312331\"\n		},\n		\"status\": 1 \n	} \n}\n```\n\n以下是做法：\n建立許多物件，最後在return最終的物件即可。\n```java\npublic class Attraction {\n    private int id;\n    private String name;\n    private String address;\n\n    // Getter and Setter methods\n}\n\npublic class Trip {\n    private Attraction attraction;\n    private String date;\n    private String time;\n\n    // Getter and Setter methods\n}\n\npublic class Contact {\n    private String name;\n    private String email;\n    private String phone;\n\n    // Getter and Setter methods\n}\n\npublic class Data {\n    private String number;\n    private int price;\n    private Trip trip;\n    private Contact contact;\n    private int status;\n\n    // Getter and Setter methods\n}\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Attraction attraction = new Attraction();\n        attraction.setId(11);\n        attraction.setName(\"艋舺龍山寺\");\n        attraction.setAddress(\"臺北市  萬華區廣州街211號\");\n\n        Trip trip = new Trip();\n        trip.setAttraction(attraction);\n        trip.setDate(\"2023-10-18\");\n        trip.setTime(\"morning\");\n\n        Contact contact = new Contact();\n        contact.setName(\"aaa\");\n        contact.setEmail(\"aaa@aqua.com\");\n        contact.setPhone(\"0912312331\");\n\n        Data data = new Data();\n        data.setNumber(\"B1696393420\");\n        data.setPrice(2000);\n        data.setTrip(trip);\n        data.setContact(contact);\n        data.setStatus(1);\n\n        // 將Data對象轉換為JSON\n        ObjectMapper objectMapper = new ObjectMapper();\n        String jsonData = objectMapper.writeValueAsString(data);\n\n        System.out.println(jsonData);\n    }\n}\n```\n\n\n## Keypoint\n      ',NULL,'2024-03-12 09:23:35',0,'NB141dbe225717cac24196d99b9ebf77b4'),('N805f84775e9abd97079dc97ac0773ad6','邀請協作者','如何分享筆記本給同伴共同編輯？','# 邀請協作者\n## Question\n如何分享筆記本給同伴共同編輯？\n\n### 正文\n想要邀請同伴閱讀自己的筆記本，可以點選左邊側邊欄的筆記本後，點選右上方的按鈕，如下圖所示。\n![邀請協作者表單](https://github.com/joeyliao127/LinkNote/blob/main/img/demo/inviteCollaborator.jpg?raw=true)\n\n點選後會出現一個表單，可以輸入想要分享對象的email，並附上邀請訊息，發送邀請後可以在側邊欄的Invitation management頁面中，找到自己發送出去的筆記本邀請。\n![Invitation management](https://github.com/joeyliao127/LinkNote/blob/main/img/demo/Invitations.jpg?raw=true)\n上面的Pending Received Invitation是別人發送給自己邀請。\n下面的Pending Sent invitation則是自己發送給別人的邀請。\n\n比如發送 `LinkNote使用教學` 筆記本給Joey Liao，當Joey Liao接受邀請後，在Joey Liao的側邊欄Collaborator的頁面將會出現 `LinkNote使用教學`筆記本。\n![共編筆記本](https://github.com/joeyliao127/LinkNote/blob/main/img/demo/CollaborativeNotebook.jpg?raw=true)\n\n## Keypoint\n如何分享筆記本給同伴共同協作：\n1. 點選左邊側邊欄MyNotebooks底下的筆記本\n2. 點選右上方邀請共編的按鈕\n3. 輸入email和邀請訊息後發送邀請\n4. 發送邀請後點選側邊欄的 `Invitation Management` 頁面查看已發送的邀請。\n      ','如何分享筆記本給同伴共同協作：','2024-03-12 07:37:13',0,'NB6bb61275bffb47586a57f94ca21f88a8'),('N8684b3ba39118091599b7e46f89c1aff','驗證請求參數','驗證請求參數的ㄈ','# 驗證請求參數\n\n## Question\n驗證請求參數的ㄈ\n## Keypoint\n      ',NULL,'2024-03-12 09:31:16',0,'NB141dbe225717cac24196d99b9ebf77b4'),('N88abb12d00fbf52ed7b13803c3334c71','2024-02-27 CORS','2024-02-27 CORS開發紀錄','# 2024-02-27 CORS\n\n## Question\n2024-02-27 CORS開發紀錄\n### 紀錄\n#### 14:35\n結果今天還是在處理CORS，不過對於CORS有了新的認知，因為今天的狀況很特殊。\n\n情況說明：\nNginx: localhost:80\n開發環境：localhost:8082\n\n我在Nginx有設定`Allow origin`為localhost:8082(開發用的port)，在後端Spring boot也都有設定CORS，會設定兩邊是因為設定Nginx後，依然無法跨域訪問，問了GPT又在那邊亂回答，說後端也要設定CORS，所以就在Spring也加上CORS。\n\n接著就發生一個意想不到的結果，那就是我發出一個註冊的請求後，瀏覽器顯示該請求被阻擋，接著下面一行又顯示200，如下：\n![[Pasted image 20240227143903.png]]\n上面這張截圖是signin的截圖，不是註冊，但是註冊時也是回應200，我就想說這是什麼情況，有CORS然後還回應200?? 我馬上打開DB查看是否真的建立了User，結果還真的建立了user，就是有CORS擋住還執行成功，這時候我的大腦直接短路，想說這是啥小情況。\n\n後來查看fetch請求後的response header，發現有兩個`allow-origin`，很明顯這代表Nginx和Spring都設定CORS，兩個重複的header導致瀏覽器報錯。\n\n也就是說後端允許跨域，所以執行了註冊使用者的操作，但Nginx不允許跨域(後來發現是設定有問題)，所以拒絕了CORS訪問，又將流量導向Spring，就產生了**被CORS阻擋，卻又能夠執行後端**的奇耙狀況。\n\n##### 解決方案\n為什麼剛才會提到Nginx不允許跨域，是因為Nginx設定的CORS有問題，具體出在哪我也不確定，但可以肯定的是Nginx沒有在response header中回應`allow origin`，所以前端8082才無法跨域請求。\n\n會發現這個是因為我想說CORS讓Nginx處理，所以把Spring的CORS設定拿掉，結果發現還是不能跨域請求，才進而發現Nginx設定的CORS，response header中根本沒有`allow origin`的資訊。\n\n所以最後我直接讓Spring處理CORS，而Nginx只負責代理路徑。結案！\n\n雖然這篇沒解決我的問題，卻值得看一看 - [Nginx處理前後端分離跨域問題](https://xuqilong.top/pages/16532e/#%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BF%A1%E6%81%AF)\n\n\n#### 23:00\n今天下午到晚上都在搞前端，感覺上都差不多，只是用了Class撰寫。\n只是前端HTML的元素一多起來，整個就很難撰寫CSS，寫到後面就有點小亂，等等來睡明天繼續！\n\n      ',NULL,'2024-03-12 08:32:10',1,'NBcb38e3739df86de4b7af6edb9821257d'),('N92bfab7d8f38c6981d6ddc1fa2218de6','2024-02-14','2024-02-14開發紀錄','# 2024-02-14\n\n## Question\n2024-02-14開發紀錄\n\n### 紀錄\n\n今天是大年初五，終於可以回家好好用三個螢幕寫code，今天要做的事情是把剩下的tag, collaborator, invitation做完，印象中invitation最難搞，等等先做invitation。\n\n今天發現後端resource server只要接收到`/api/notebooks/`開頭的請求，都會發送兩次身份驗證給auth，我在想為什麼會這樣，結果發現是`appConfig`的interceptor路徑設定有問題。\n原本的設定是將`/api/notebooks/**`這個路徑放在最後，用來驗證notebooks請求，結果`/api/notebooks/`開頭的，如tag, invitation, note的前綴通通都有`/api/notebooks`，導致發一次請求驗證了兩次。\n\n## 解法\n把tag, invitation, note, collaborators都排除在`/api/notebooks/**`這隻register。\n```java\nregistry.addInterceptor(notebookInterceptor).addPathPatterns(\"/api/notebooks/**\", \"/api/coNotebooks\")  \n    .excludePathPatterns(  \n        \"/api/notebooks/*/invitations\",  \n        \"/api/notebooks/*/notes/**/\",  \n        \"/api/notebooks/**/notes/**/tags/**\",  \n        \"/api/notebooks/*/collaborators\"  \n    );\n```\n這樣就不會重複發送驗證請求。',NULL,'2024-03-12 08:12:53',0,'NBcb38e3739df86de4b7af6edb9821257d'),('N98218872b92df908f69f8a733ddeee8a','Authentication','Authentication API規格','# Authentication API規格\n\n## Question\nAuthentication API規格\n\n### APIs\n#### Authentication Server Endpoint\nAuth Server有兩種，一種是User，前端會call User相關的API，另一種是auth，只有Resource會call。\n\nUser\n- 註冊帳號\n- 使用者帳密登入\n- Token登入\n- 更新使用者資訊\n- 透過token取得user資訊\n## User\n### 註冊帳號\npath\n```json\nPOST /api/user/register\n```\nRequest Param\n```\nnone\n```\nPath Variable\n```\nnone\n```\nRequestBody\n```json\n{\n	\"email\": \"joey.liao@gmail.com\",\n	\"username\": \"Joey Liao\",\n	\"password\": \"abc123\"\n}\n```\nemail: @Email，驗證Email Format\nusername: @NotBlank\npassword: @NotBlank\ntoken\n```\ntoken: false\n```\nResponse Body\n```json\n{\n	\"token\": \"eyJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE3MDgwNTI2MzYsImlzcyI6ImxpbmtOb3RlIiwiZXhwIjoxNzEwNDcxODM2LCJzdWIiOiJKb2V5IExpYW8iLCJ1c2VySWQiOiI4YjNlNjJkZi1kYTA5LTQ5NTUtYWU2MC04ZjAxNDM3MjAyMTciLCJlbWFpbCI6ImpvZXkubGlhb0BnbWFpbC5jb20ifQ.SObjVQ4kyoP9Hssd7VRTPBNp7hSQoTyAg6EHWsAuLmE\"\n}\n```\n\n### 使用者帳密登入\npath\n```json\nPOST /api/auth/user/signin\n```\nRequest Param\n```\nnone\n```\nPath Variable\n```\nnone\n```\nRequestBody\n```json\n{\n	\"email\": \"joey.liao@gmail.com\",\n	\"password\": \"abc123\"\n}\n```\nemail: @Email，驗證Email Format\npassword: @NotBlank\n\ntoken\n```\ntoken: false\n```\n\nResponse Body\n```json\n{\n	\"result\": true,\n	\"token\": \"eyJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE3MDgwNTI4MjIsImlzcyI6ImxpbmtOb3RlIiwiZXhwIjoxNzEwNDcyMDIyLCJzdWIiOiJKb2V5IExpYW8iLCJ1c2VySWQiOiI4YjNlNjJkZi1kYTA5LTQ5NTUtYWU2MC04ZjAxNDM3MjAyMTciLCJlbWFpbCI6ImpvZXkubGlhb0BnbWFpbC5jb20ifQ.eFUGJtm-2UlEeBYqwTVfRH6igDQf38ET0deOeJ7J8gA\"\n}\n```\n\n### Token登入\npath\n```json\nPOST /api/auth/user/token\n```\nRequest Param\n```\nnone\n```\nPath Variable\n```\nnone\n```\nRequestBody\n```json\nnone\n```\ntoken\n```\ntoken: true\n```\nResponse Body\n```json\ntrue / false\n```\n\n### 更新使用者資訊\npath\n```json\nPUT /api/user\n```\nRequest Param\n```\nnone\n```\nPath Variable\n```\nnone\n```\nRequestBody\n```json\n{\n	\"email\": \"joey.liao@gmail.com\",\n	\"username\": \"Joey Liao\",\n	\"password\": \"abc123\"\n}\n```\n可以更新username, password，不能更改email!! email只是用來寫sql的WHERE條件。\n\ntoken\n```\ntoken: true\n```\nResponse Body\n```json\n{\n	\"result\": true\n}\n```\n\n### 透過token取得user資訊\npath\n```json\nGET /api/user\n```\nRequest Param\n```\nnone\n```\nPath Variable\n```\nnone\n```\nRequestBody\n```json\nnone\n```\ntoken\n```\ntoken: true\n```\nResponse Body\n```json\n{\n	\"username\": \"Joey Liao\",\n	\"userId\": \"8b3e62df-da09-4955-ae60-8f0143720217\",\n	\"email\": \"joey.liao@gmail.com\",\n	\"status\": null\n}\n```\n\n## 驗證權限\n驗證路徑\n```paht\n/api/auth/notebook\n/api/auth/note\n/api/auth/tag\n/api/auth/collaborator\n/api/auth/inviation\n/api/user/authentication\n```\n請求參數\n```json\n{\n	\"notebookId\": \"notebookId\",\n	\"behavior\": \"behavior\"\n}\n```\n返回結果\n```\nBoolean\n```\n單純為一個boolean，直接讓interceptor return。\n\n### 例外\n在Authentication Server有一個驗證權限是例外，就是關於所有Notebook的操作，因為以下四點操作不需要notebookId：\n- GET所有notebook\n- CREATE一個新的notebook\n- GET sent-Invitation\n- GET received-Invitation\n\n因此Resource Server的攔截器捕捉到取得所有notebook或CREATE新的notebook請求，就直接發給驗證token的endpoint，查到有此身份則回傳true。\n\n\n\n      ',NULL,'2024-03-12 09:06:50',1,'NB42801eed039177f8620d4c63b3f8acb5'),('N9976163068601145872c604c6eb4da1e','2024-03-02','2024-03-02開發紀錄','# 2024-03-02\n\n## Question\n2024-03-02開發紀錄\n\n### 紀錄\n不知不覺又過了一天，明天是禮拜六，先記錄一下工作階段。\n\n今天把程式碼重構了一次，對於JS的Class有更深的了解，不再是亂用this來呼叫Class中的方法，而是善用公有方法和私有方法來撰寫。\n\n除了正確使用Class，也優化了頁面的渲染流程，為了提高重複使用率，每個區塊都會有gen和render方法，render方法會取得自己的父層，並將舊的自己移除，在透過gen方法來產生新的自己，最後在append到父層即可。\n\n目前正在做filter那一排按鈕，點選後都要重新渲染noteCardCtn，透過renderNoteCardCtn實現，目前已經宣告，但尚未實作。\n待辦：\n1. 點選每個filter時，將filter參數中的值做更改。\n2. 每次renderNoteCardCtn都會根據fitler物件的屬性來建立param。\n      ',NULL,'2024-03-12 08:54:01',0,'NBcb38e3739df86de4b7af6edb9821257d'),('Na790b044432a613ef1fb17bef6adbeaf','2024-03-01','2024-03-01開發紀錄','# 2024-03-01\n\n## Question\n2024-03-01開發紀錄\n\n### 紀錄\n今天來記錄一下這幾天都在幹嘛，不外乎就是瘋狂的刻前端，雖然記取了Linknote1.0的教訓，透過重新渲染的方式和改用Class開發，但昨天還是不小心把程式碼寫亂了，因為沒有良好的架構規劃，導致程式碼出現循環依賴的問題，比如說notebook渲染Class和渲染note的Class，note class就不會需要使用notebook class，避免循環依賴的問題。再來是重新渲染和資料一制性的問題。\n\n渲染問題是指渲染應該有兩個階段，第一個階段是產生element，第二個階段才是把產生好的element，append到想要重新渲染的block中，並且把block透過innerHTML將其清空，在append element。\n\n所有的element應該都遵循這個規則，但就是要思考一個compenent要怎麼切，哪個compoent需要撰寫一個function讓他重新渲染，**取決於父層是否有其他種渲染可能**。打個比方，在紅色區域稱為notebookArea。\n![](https://github.com/joeyliao127/LinkNote/blob/main/img/demo/2024-03-01-1.png?raw=true)\n這裡面的內容會變成以下兩種情況：\n1. Notebooks，點選MyNotebook時渲染出多個筆記本(上)。\n2. Notebook，點選指定notebook後出現指定筆記內容(下)。\n![](https://github.com/joeyliao127/LinkNote/blob/main/img/demo/2024-03-01-2.png?raw=true)\n\n因此這個地方就需要一個Render和一個Generater。\n\n      ',NULL,'2024-03-12 08:48:30',0,'NBcb38e3739df86de4b7af6edb9821257d'),('Nae6f6e5cf9d8653ee2491c6f0cc5e963','2024-03-11 部署問題','2024-03-11 部署問題紀錄','# 2024-03-11 部署問題\n\n## Question\n2024-03-11 部署問題紀錄\n\n### 紀錄\n#### 10:02\n今天依然在排查GET請求以外會得到403的問題，昨天晚上在思考Mac環境可以正常開發，部署到VM後卻不行，明明都是用Docker模擬正式環境，卻有不同的情況，開發和正式環境唯一不同地方是在js的`FetchData.js`中，移除請求路徑的開頭，所以很直覺地認為是`FetchData.js`出了問題，因為只有這個地方和部署，再加上GET和GET以外的請求設定的Header又不一樣，又更加篤定是這個檔案出問題。\n\n再次描述問題：\n- 請求GET以外會得到403\n\n先列出目前Debug有用的資訊：\n- GET請求都能正常取得資料 -> CORS和Nginx路徑問題機率降低\n- Index.js可以發出POST請求 -> CORS問題機率降低，`FetchData.js`問題發生機率提高，但CORS也有一定的發生機率，因為Index.js發出的請求是給authenticatioin的Spring app，發生403的問題都是發請求給Resoource-app。\n- Index.js沒有使用到`FetchData.js`，`FetchData.js`問題發生機率提高。\n- DELETE請求也會得到403 -> `FetchData.js`發生問題機率降低，Nginx ＆ CORS發生機率提高，因為GET和DELETE都是用同一個Header，但GET卻可以正常取得資料。\n- 發生403時，Spring app皆沒有收到請求(查看過docker logs) -> Nginx問題機率提高。\n- Postman直接向Nginx發出PUT, POST請求是可以的 -> Nginx問題發生機率降低。\n\n可能出現問題的地方(依照優先級排序)\n- FetchData.js出現問題 -> 因為index.js沒有使用到，所以才有可能可以發POST請求登入網站。\n- CORS -> 這個問題的發生機率比Nginx路徑匹配問題還高，因為如果Nginx路徑匹配出問題，那麼就無法取得GET /api/notebooks/notebookId/notes/noteId的內容，但是GET確實可以正常訪問，但是換成PUT或POST甚至是Delete都會得到403。\n- Nginx路徑匹配問題 -> 這個問題應該不太可能，但是如果把路徑設定精準一點也許有機會解決。\n\n排查過程\n- 修改FetchData.js -> 排除FetchData.js問題\n- 測試Delete請求是否有辦法成功執行 -> 無法執行，有可能是nginx的路徑問題。\n- 測試註冊使用者`POST方法` -> 可以成功註冊使用者。\n- 在notebook管理頁面測試更改使用者密碼 -> 可以！更加篤定FetchData.js沒問題。\n\n排除到這邊基本上可以確定問題點出在於Nginx或Resource Spring app，所以開始往這兩個方向排查。\n由於Spring app都沒有收到請求，所以估計是Nginx的路徑出了問題，但是GET請求又可以執行，所以感覺Nginx出問題的機率也不是太高。\n\n- 修改Nginx路徑，新增/api這條location -> 依然得到403，所以應該不是Nginx的問題，因為Postman本來就能夠發PUT或POST請求到後端，代表Nginx可以正常代理。\n\n最後的可能就是Spring app的CROS，但是Nginx發請求給Spring boot也沒有CROS的問題，因為本來就屬於同源，但還是姑且試試看吧。\n\n- 修改Resource Spring app的Allow origin \n```\n\"http://linknote.online\",  \n\"https://linknote.online\",  \n\"http://192.168.0.201\",  \n\"https://192.168.0.201\",  \n\"http://192.168.0.203\",  \n\"https://192.168.0.203\",\n```\n\n終於搞定了，居然是CROS的問題，目前覺得很奇怪的地方有以下幾點：\n- 為什麼Nginx把流量代理給172.17.0.4(Resource-app)會有CROS問題\n- 為什麼Postman發請求給Resource-app卻沒有CROS?\n- 如果有CROS問題，又為什麼GET請求都可以通過，而GET以外的請求卻不行？\n- 如果有CROS問題，Authentication-app也沒有設定allow-origin，卻可以執行POST請求？\n- 為什麼Spring明明收到了請求，log卻沒有顯示？\n\n其實後來想想Postman和403這兩個特徵，都隱約提示了這個問題是CROS造成的，Postman很厲害都沒有CROS的問題，而403則是一般CROS回應的status code，至於上述問題有時間還是得查一下，但以結論來說，Nginx將流量導給Spring app確實存在CROS問題。\n\n## Keypoint\n被CORS搞慘了，居然有不同主機的跨域問題...\n      ','被CORS搞慘了，居然有不同主機的跨域問題...','2024-03-12 09:04:33',1,'NBcb38e3739df86de4b7af6edb9821257d'),('Nae8920d3849b62e7aa878944c7a83b44','RequestMethod','如何接收指定http method的request?','# RequestMethod\n\n## Question\n如何接收指定http method的request?\n\n### Mapping\n在RequestMapping中加入method，即可指定前端發出的方法。\n```java\n@RequestMapping(value = \"/postTest\", method = RequestMethod.POST)  \npublic List<String> getBodyParam(@RequestBody getBodyData data){  \n    List info = new ArrayList<String>();  \n    info.add(data.getName());  \n    info.add(data.getAge());  \n    info.add(data.getPhone());  \n    return info;  \n}\n```\n\n也可以使用PostMapping註解指定接收POST方法的請求。\n```java\n@PostMapping(\"/getAuthoriztion\")  \npublic String getAuthorization(@RequestHeader(defaultValue = \"\") String Authorization){  \n    return Authorization;  \n}\n```\n\n共有以下幾種註解可以使用：\n@GetMapping  \n@PutMapping  \n@DeleteMapping  \n@PostMapping\n\nGET和Delete方法都會指定讀取/刪除的資源，指定的條件都只能放在URL裡面。\nPUT和POST方法則會將資源都放在ReqeustBody中。\n\n## Keypoint\n透過以下四種註解接收指定method的請求。\n- @GetMapping  \n- @PutMapping  \n- @DeleteMapping  \n- @PostMapping\n      ','透過以下四種註解接收指定method的請求。','2024-03-12 09:29:21',0,'NB141dbe225717cac24196d99b9ebf77b4'),('Nb825ecfc04a4d7195737a33150e293f9','2024-03-07 結案','2024-03-07 結案紀錄','# 2024-03-07 結案\n\n## Question\n2024-03-07 結案紀錄\n\n### 紀錄\n#### 9:27\n今天一早先修了一些Bug，昨天太晚睡今天整個沒精神，不知道為什麼七點就醒了，可能是因為聽到一些好消息所以太興奮XD，也可能是因為今天就可以把專案搞定，廢話不多說趕緊把剩下的弄完吧！\n- [x] 將notebook的tag渲染到TopBar\n- [x] 顯示topBar的Collaborator\n- [x] 刪除note按鈕\n- [x] 更新note名稱，透過點擊後更改h1標籤\n- [x] 點topbar的漢堡要關閉sidebar的tag和filter表單\n- [x] 點選SideBar的筆記後渲染topBar和main\n- [x] 新增note\n\n#### 22:36\n終於把專案做完了！！！但其實還有許多可以優化的地方，而且部署還沒上AWS，前端md的撰寫區域都可以在修改，新增個plug in什麼的，因此明天的代辦事項：\n專案部分：\n- [ ] TUI editor新增語法高亮和其他樣式更改，\n- [ ] 新增閱讀和撰寫模式\n- [ ] 檢查整個專案的print和console.log，把不必要的註解移除。\n- [ ] 撰寫readme\n- [ ] 加入自己的筆記透過Python寫入mysql，快速建立筆記內容。\n- [ ] 部署到AWS。\n- [ ] 心得整理\n- [ ] 刷題和學習資料結構\n- [ ] 更新履歷\n- [ ] 整理筆記\n\n未來有時間可以執行以下事項\n系統架構：\n- 思考如何加入Redis使用在專案中\n- Nginx加入輪詢，透過工具測試網站性能(在PVE主機)\n- MySQL叢集讀寫分離\n- MySQL透過explain觀察語法之間或index\n- K8s & Docker compose\n- 串接第三方登入\n- CI/CD (Github Actions)\n\n軟體知識：\n- 資料結構 - 實作\n	- Queue\n	- Stack\n	- Tree\n	- Map\n	- 深度優先\n	- 廣度優先\n	- 圖\n- 設計模式\n	- 單例模式\n	- 工廠模式\n	- 建造模式\n	- 觀察者模式\n- Java\n	- JVM\n	- GC機制\n\n      ',NULL,'2024-03-12 09:02:38',0,'NBcb38e3739df86de4b7af6edb9821257d'),('Ncae74ed6e1cd927f7610879fe726945c','2024-02-24','2024-02-24開發紀錄','# 2024-02-24\n\n## Question\n2024-02-24開發紀錄\n\n### 紀錄\n今天代辦：\n- [ ] 處理CORS問題，由於Nginx還沒建置，所以要先建立Nginx服務，未來就可以透過Domain來呼叫API，這樣就不會遇到CORS，但是在開發前端時還是需要允許125.229.110.93的CORS，允許從家裏發出API。最好是用Docker來部署Nginx，但目前先直接用實體Nginx。\n- [ ] 看要不要將app的路徑分為/api/auth和/api/resource開頭，讓Nginx分給相對應的app處理。\n- [ ] 整理出Figma中的所有圖片，丟到S3並建置Cloud Front CDN\n\n\n後來想想應該要在Mac先透過Docker把服務跑起來，這樣前端就可以call本地的API也不用更改網址，還可以順便處理CORS和透過Docker file部署服務。\n所以順序應該為：\n1. 在Mac透過Docker運行Nginx和Spring boot。\n	1. Nginx設定檔要研究如何寫在Docker Container裡面\n	2. 建立app資料夾，將Spring boot外部配置文件和jar檔案放到app資料夾中。\n2. 將前端靜態圖片都丟到Cloud Front CDN。\n3. 撰寫前端頁面\n\n總結，今天開始學習Docker，程度要到熟悉Docker compose。\n\n記錄一下今天做了什麼。(16:00)\n1. 將Nginx的設定檔寫好，有辦法根據prefix將流量導向相對應的app。\n2. 將Nginx設定SSL憑證。\n3. 將EC2安全群組中的HTTP和HTTPs的限制設為公開。\n\n記錄一下今天做了什麼(23:00)\n1. 學習Dockerfile撰寫和Docker基礎知識。\n2. 設定Nginx\n\n明日代辦：\n1. 學習Docker網路，如何將app串接到Mac的MySQL。\n2. 研究Docker container的Nginx，如何引入SSL憑證和將設定檔加入`site-avalable`。\n\n\n      ',NULL,'2024-03-12 08:28:14',0,'NBcb38e3739df86de4b7af6edb9821257d'),('Ne50c310146ff2d62d8a555afc6182528','2024-02-05','2024-02-05開發紀錄','# 2024-02-05\n\n## Question\n\n2024-02-05開發紀錄\n\n# 記錄\n\n今天完成了驗證App，可以根據role來取得權限。主要完成了擴展說明的部分，其餘的就是思考cors的問題，因為8081(resource)要訪問8080，因此在configuration中設定了一些參數。\n\n剩下的就是開始建立resource app，初始化pom.xml和application.properties。今天只有建立好interceptor和設定interceptor在AppConfig中，明天要先測試攔截器是否能夠依照Config設定來發請求到Auth。\n\n```java\n@Override  \npublic void addInterceptors(InterceptorRegistry registry) {  \n  registry.addInterceptor(tagInterceptor).addPathPatterns(\"/api/notebooks/*/notes/*/tags/**\");  \n  registry.addInterceptor(noteInterceptor).addPathPatterns(\"/api/notebooks/*/notes/**\");  \n  registry.addInterceptor(invitationInterceptor).addPathPatterns(\"/api/notebooks/*/invitation/**\");  \n  registry.addInterceptor(collaboratorInterceptor).addPathPatterns(\"/api/notebooks/*/collaborators/**\");  \n  registry.addInterceptor(notebookInterceptor).addPathPatterns(\"/api/notebook/**\").excludePathPatterns(\"/api/notebook/create\");  \n}\n```\n\n## Keypoint\n1. 完成使用者身份驗證',NULL,'2024-03-12 08:05:27',0,'NBcb38e3739df86de4b7af6edb9821257d'),('Nebc2164f208d96484c9c20efdda4f92b','LinkNote基本介紹','如何使用LinkNote? 了解LinkNote使用方式！','# LinkNote\n\n## Question\n\n如何使用LinkNote? 了解LinkNote使用方式！\n\n### 介紹\n\nLinkNote是一款線上筆記網站，主要有以下四點特色。\n\n1. 支援Markdown語法進行筆記編輯\n2. 允許分享筆記本給同伴共同協作筆記\n3. 透過多個Filter快速篩選筆記\n4. 透過CODE概念撰寫筆記\n\n### 使用方式\n\n在建立筆記之前，首先要建立筆記本，登入後點選左邊側邊欄的 `New Notebook`，新增一個筆記本。\n![CreateNotebook](https://github.com/joeyliao127/LinkNote/blob/main/img/demo/CreateNotebook.jpg?raw=true)\n\n* Notebook Name：輸入筆記本名稱，這格是必填的。\n* Description：描述此筆記本的用途，撰寫建立筆記本的目的。\n* Tags：用來建立筆記本的tag，未來建立筆記時可以將筆記加上tag，方便歸類且方便搜尋筆記。\n\n完成後點選Submit即可建立筆記本，接著側邊欄的 `MyNotebook`底下就會多一個筆記本，點選筆記本後就可以按下右上角的 `New note` 新建筆記。\n![createNote](https://github.com/joeyliao127/LinkNote/blob/main/img/demo/CreateNote.jpg?raw=true)\n\n接著就會跳轉到撰寫筆記的畫面，這裡就可以開始撰寫筆記！\n![writeNote](https://github.com/joeyliao127/LinkNote/blob/main/img/demo/writeNote.jpg?raw=true)\n\n\n## Keypoint\n這篇筆記介紹了LinkNote有哪些特色以及如何使用，這邊總結一下上述提到的重點：\n1. LinkNote支援Markdown語法和分享筆記本給同伴的功能\n2. 在建立筆記之前需要先建立筆記本\n\n其他關於LinkNote的相關操作，可以參考LinkNote使用教學筆記本的其他篇筆記！','這篇筆記介紹了LinkNote有哪些特色以及如何使用，這邊總結一下上述提到的重點：','2024-03-12 05:15:17',1,'NB6bb61275bffb47586a57f94ca21f88a8'),('Nf47cbd6f59d0b680b9062c745f760747','CODE概念','何謂CODE？如何透過CODE的方式撰寫筆記。','# CODE\n\n## Question\n何謂CODE？如何透過CODE的方式撰寫筆記。\n\n### 筆記的本質\n做筆記的本質為何？是搜集一切個人認為有用的信息？還是透過筆記來回憶學習過的事物？\n\n關於筆記的本質，我的看法是 **提高生產效率**，無論是搜集信息還是回憶學習過的事物，本質上都是當我們需要使用到這個知識時，有一個快速且高效的方式喚醒腦中的記憶，而不需要從頭查起，提高解決問題的效率。\n\n解了於筆記的本質，接著一起探討什麼是CODE。\n\n### 什麼是CODE?\n所謂的CODE是一個簡稱，是由Tiago Forte在他的名著 **打造第二大腦** 中提到的方法。\n* **C -> capture**：用來捕捉信息\n* **O -> organize**：對信息做組織化的整理，將信息歸類。\n* **D -> distill**：將歸類好的信息萃取出重點。\n* **E -> Express**：將萃取出的重點表達給他人。\n\n為了實現CODE的概念，因此在LinkNote的筆記撰寫區域，在新建筆記時預設就存在了 `Question` 和  `Keypoint` 兩個標題。\n\n---\n**Question** ：Question標籤是用來實現 **Capture**  的概念，因為在 **Capture** 的階段，要先釐清信息內容本身是否有紀錄的價值，而確認信息是否有價值則是依據自己的**需求**為何，如果這條信息可以解決某件事情或者提高效率，那麼這就是有價值的信息。因此Question欄位底下，透過思考**需求**的角度，確認信息是否和需求是否有關連，從而確定這是一條有用的信息。\n\n而Question欄位還有一個用途，如果有在筆記中保留此欄位，那麼在notebook管理介面的筆記中，就會顯示這篇筆記Question底下的內容，這樣就可以在點進筆記之前，就先知道此筆記的用途為何。\n![question](https://github.com/joeyliao127/LinkNote/blob/main/img/demo/Question.jpg?raw=true)\n\n\n\n---\n**Keypoint**：Keypoint標籤是用來實現 **Distill**的概念，將已經歸類好的信息做最後的重點萃取，未來在回顧筆記時，可以先閱讀Keypoint的內容回想重點，再深入研究筆記中的其他細節。\n\n\n概念參考於：[Youtube: MoneyXYZ - 為什麼你不需要\"第二大腦\"或者\"個人知識庫\"？](https://www.youtube.com/watch?v=5kNCcpM61eo)\n\n## Keypoint\n這篇筆記介紹了CODE的概念是由 **Capture** 、 **Organize** 、 **Distill** 、 **Express** 等四個步驟建立有價值的筆記，\n\n1. 筆記的本質是為了提高生產效率。\n2. 透過CODE的概念建立有價值的筆記。','這篇筆記介紹了CODE的概念是由 Capture 、 Organize 、 Distill 、 Express 等四個步驟建立有價值的筆記，','2024-03-12 06:05:30',1,'NB6bb61275bffb47586a57f94ca21f88a8'),('Nf8baae4d761cf4535a4760df2bd61c37','Resource','Resource API規格紀錄','# Resource API規格\n\n## Question\nResource API規格紀錄\n\n### API規格\nNotebooks\n- 新增notebook\n- 取得所有notebooks\n- 取得所有coNotebooks\n- 更新notebook\n- 更新notebook\n\nNotes\n- 新增note\n- 取得notes\n- 取得note\n- 更新note\n- 刪除Note\n\nInvitations\n- 新增invitation\n- 取得sent-invitation\n- 取得received-invitation\n- 更新invitation\n- 刪除Invitation\n\ncollaborator\n- 取得collaborators\n- 刪除collaborator\n\ntag\n- 新增notebook Tag\n- 新增note tag\n- 取得Notebook Tag\n- 取得note tag\n- 刪除notebook Tag\n- 刪除note tag\n\n\n#### Notebooks\n共有五隻API：\n\n##### 新增notebook\npath\n```\nPOST /api/notebooks\n```\nRequest Param\n```\nNone\n```\nPath Variable\n```\nNone\n```\nRequestBody\n```json\n{\n	\"name\": \"Joey\",\n	\"description\": \"Joey test\"\n}\n```\ntoken:\n```\ntoken：true\n```\nResponse Body\n```json\n{\n	\"result\": true\n}\n```\n\n##### 取得所有notebooks\npath\n```\nGET /api/notebooks\n```\nRequest Param\n```\nlimit: required = false, default=1  用途：用來請求一次幾筆資料\noffset: required = false, default=0 用途：請求從地幾筆資料開始取得\nkeyword: required = false 用途：透過關鍵字查找筆記\n```\nPath Variable\n```\nNone\n```\nRequestBody\n```\nNone\n```\ntoken\n```\ntoken: true\n```\nResponse Body\n```json\n{\n	\"notebooks\": [\n		{\n			\"id\": \"NBJAVA\",\n			\"name\": \"Java\",\n			\"description\": \"Test\"\n		},\n		{\n			\"id\": \"NBPython\",\n			\"name\": \"Python\",\n			\"description\": \"Test\"\n		}\n	],\n	\"nextPage\": false\n}\n```\n\n##### 取得所有coNotebooks\npath\n```\nGET /api/coNotebooks\n```\nRequest Param\n```\nlimit: required = false, default=1  用途：用來請求一次幾筆資料\noffset: required = false, default=0 用途：請求從地幾筆資料開始取得\nkeyword: required = false 用途：透過關鍵字查找筆記\n```\npath Variable\n```\nnone\n```\nRequestBody\n```\nNone\n```\ntoken\n```\ntoken: true\n```\nResponse Body\n```json\n{\n	\"notebooks\": [\n		{\n			\"id\": \"NBJAVA\",\n			\"name\": \"Java\",\n			\"description\": \"Test\"\n		},\n		{\n			\"id\": \"NBPython\",\n			\"name\": \"Python\",\n			\"description\": \"Test\"\n		}\n	],\n	\"nextPage\": false\n}\n```\n\n##### 更新notebook\npath\n```json\nPUT /api/notebooks/{notebookId}\n```\nRequest Param\n```\nNone\n```\nPath Variable\n```\nnotebookId: 要更新的notebookId\n```\nRequestBody\n```\n{\n	\"name\": \"Joey C++\",(這個也要帶入，即便只更新description)\n	\"description\": \"Joey Update test\"\n}\n```\ntoken\n```\ntoken: true\n```\nResponse Body\n```json\n{\n	result: true\n}\n```\n\n##### 刪除notebook\npath\n```\nPUT /api/notebooks/{notebookId}\n```\nRequest Param\n```\nnone\n```\nPath Variable\n```\nnotebookId: 要刪除的notebookId\n```\nRequestBody\n```\nNone\n```\ntoken\n```\ntoken: true\n```\nResponse Body\n```\n{\n	result: true\n}\n```\n\n#### notebook細節說明\n1. Pagination分頁：\n	在[[API文件 - Resource#取得所有notebooks|取得所有notebooks和coNotebooks]] api中，後端收到請求後會對limit值加1，為了確認是否有nextPage。\n	若查詢出的筆數 = limit + 1，那麼就代表還有下一頁，最中return結果時指需要remove最後一筆資料即可。\n2. 權限驗證：\n	權限驗證的部分，攔截器取得`GET, POST /api/notebooks`, `GET /api/coNotebooks`時，會發送驗證請求到Auth的`/api/user/auth/token`這個路徑，而不是Auth的`/api/auth/notebook`。因為`/api/auth/notebook`需要具體指明哪一個`notebookId`，有`Target`才能對`Target`做CRUD。\n#### Notes\n共有五隻API\n\n##### 新增note\nPath\n```\nPOST /api/notebooks/{notebookId}/notes\n```\nRequest Param\n```\nnone\n```\nPath Variable\n```\nnotebookId: 要建立note的notebookId\n```\nRequestBody\n```\nnone\n```\ntoken\n```\ntoken: true\n```\nResponse Body\n```json\n{\n	\"result\": true,\n	\"noteId\": \"N1bd550a6861f8504941e9c5380e27e02\"\n}\n```\n剛新建好的note名稱都叫做new note\n\n##### 取得notes\n這個還要改，notes回傳資訊應該要包含tag\npath\n```json\nGET /api/notebooks/{notebookId}/notes?limit=3&offset=0&keyword=java\n```\nRequest Param\n```\nnone\n```\nPath Variable\n```\nnotebookId: 要取得notes的notebookId\n```\nRequestBody\n```\nnone\n```\ntoken\n```\ntoken: true\n```\nResponse Body\n```json\n{\n	\"notes\": [\n		{\n			\"noteId\": \"N1bd550a6861f8504941e9c5380e27e02\",\n			\"name\": \"new Note\",\n			\"question\": null,\n			\"content\": null,\n			\"keypoint\": null,\n			\"createDate\": \"2024-02-15 10:16:12\",\n			\"star\": false\n		},\n		{\n			\"noteId\": \"NJ1\",\n			\"name\": \"java note1\",\n			\"question\": \"test\",\n			\"content\": null,\n			\"keypoint\": null,\n			\"createDate\": \"2024-02-14 16:28:40\",\n			\"star\": true\n		},\n	],\n	\"nextPage\": true\n}\n```\n###### 開發思路\n取得Note和Notes，原本在思考要請求一次後，取得和該note相關的tag，還是分次請求，想了想還是一次請求完畢比較合適。\n\n因此在Get Note時，在noteService需要注入tagService取得指定noteId的tag取出，並set到Response中。\n\n##### 取得note\n這還要改，加上tag資訊。\npath\n```\nGET /api/notebooks/{notebookId}/notes/{noteId}\n```\nRequest Param\n```\nnone\n```\nPath Variable\n```\nnotebookId: 要取得note的notebookId\nnoteId: 要取得的noteId\n```\nRequestBody\n```\nnone\n```\ntoken\n```\ntoken: true\n```\nResponse Body\n```json\n{\n	\"note\": {\n		\"noteId\": \"N1bd550a6861f8504941e9c5380e27e02\",\n		\"name\": \"new Note\",\n		\"question\": null,\n		\"content\": null,\n		\"keypoint\": null,\n		\"createDate\": \"2024-02-15 10:16:12\",\n		\"star\": false\n	}\n}\n```\n\n##### 更新note\npath\n```\nPUT /api/notebooks/{notebookId}/notes/{noteId}\n```\nRequest Param\n```\nnone\n```\nPath Variable\n```\nnotebookId: 要更新note的notebookId\nnoteId: 要更新的noteId\n```\nRequestBody\n```json\n{\n	\"name\": \"Java note5\",\n	\"question\": \"test\",\n	\"content\": \"test\",\n	\"keypoint\": \"test\",\n	\"star\": true\n}\n```\n以上參數都是required false，但至少要有一個參數，不然會報錯。\n\ntoken\n```\ntoken: true\n```\nResponse Body\n```json\n{\n	\"result\": true\n}\n```\n\n##### 刪除Note\npath\n```json\nDELETE /api/notebooks/NBJAVA/notes/{noteId}\n```\nRequest Param\n```\nnone\n```\nPath Variable\n```\nnotebookId: 要建立note的notebookId\n```\nRequestBody\n```\nnone\n```\ntoken\n```\ntoken: true\n```\nResponse Body\n```json\n{\n	\"result\": true\n}\n```\n\n#### Invitation\n共有五個API\n\n##### 新增invitation\nPath\n```\nPOST /api/notebooks/{notebookId}/invitations\n```\nRequest Param\n```\nnone\n```\nPath Variable\n```\nnotebookId: 要建立invitation的notebookId\n```\nRequestBody\n```json\n{\n	\"message\": \"test發送給A2 Java Notebook的共編邀請\",\n	\"inviteeEmail\": \"a2@test.com\"\n}\n```\ntoken\n```\ntoken: true\n```\nResponse Body\n```json\n200 - 成功\n{\n	\"result\": true\n}\n\n400 - Email不存在\n{\n	\n}\n\n409 - Invitation已經存在\n{\n	 \"result\": false\n}\n```\nmessage：required false\ninviteeEmail：required true\n\n#### 開發思路\n在Create invitation時，在`create`之前要先檢查`invitation`表中，是否有`notebookId`,`Inviee`,`isPending` = 1的欄位，如果有代表之前已經發過邀請，除非`isPending`變成0代表已經關閉，並且**isAccept**的狀態為0(代表沒接受)，才可以重新發出邀請。\n\n所以`create`的流程為：\n1. 接收前端`notebook`和`invitee`請求資訊。\n2. Service層檢查之前是否已經存在相同的邀請，若有存在且`isPending`欄位為1，代表此邀請還沒關，並**返回200** status code，因為前端只是想create Invitation，如果存在，回傳200或400對於實際需求並無差別。\n3. 檢查邀請的inviteeEmail是否存在於資料庫，確認有此user。\n4. 檢查結束後確認沒有重複且已開啟的invitation，create invitation。\n\n##### 取得sent-invitation\npath\n```json\nGET /api/invitations/sent-invitations?offset=0&limit=2\n```\nRequest Param\n```\nlimit: required = false, default=1  用途：用來請求一次幾筆資料\noffset: required = false, default=0 用途：請求從地幾筆資料開始取得\nkeyword: required = false 用途：透過關鍵字查找invitation\n```\n目前sql裡面還沒加上keyword，所以keyword是無效的。\n\nPath Variable\n```\nnone\n```\nRequestBody\n```json\nnone\n```\ntoken\n```\ntoken: true\n```\nResponse Body\n```json\n{\n	\"nextPage\": false,\n	\"invitations\": [\n		{\n			\"notebookName\": \"Java\",\n			\"notebookId\": \"NBJAVA\",\n			\"message\": \"test發邀請給userA3成為Java筆記本的collaborator\",\n			\"createDate\": \"2024-02-14 16:28:40\",\n			\"inviteeName\": \"a3\",\n			\"inviteeEmail\": \"a3@test.com\"\n		},\n		\n		{\n			\"notebookName\": \"Python\",\n			\"notebookId\": \"NBPython\",\n			\"message\": \"test發邀請給userA3成為Python筆記本的collaborator\",\n			\"createDate\": \"2024-02-14 16:28:41\",\n			\"inviteeName\": \"a3\",\n			\"inviteeEmail\": \"a3@test.com\"\n		}\n	]\n}\n```\n\n##### 取得received-invitation\npath\n```json\nGET /api/invitations/received-invitations\n```\nRequest Param\n```\nlimit: required = false, default=1  用途：用來請求一次幾筆資料\noffset: required = false, default=0 用途：請求從地幾筆資料開始取得\nkeyword: required = false 用途：透過關鍵字查找invitation\n```\nPath Variable\n```\nnotebookId: 要建立note的notebookId\n```\nRequestBody\n```json\nnone\n```\ntoken\n```\ntoken: true\n```\nResponse Body\n```json\n{\n	\"nextPage\": false,\n	\"invitations\": [\n		{\n			\"notebookName\": \"Java\",\n			\"notebookId\": \"NBJAVA\",\n			\"message\": \"test發邀請給userA3成為Java筆記本的collaborator\",\n			\"createDate\": \"2024-02-14 16:28:40\",\n			\"inviterName\": \"test\",\n			\"inviterEmail\": \"test@test.com\"\n		},\n		{\n			\"notebookName\": \"Python\",\n			\"notebookId\": \"NBPython\",\n			\"message\": \"test發邀請給userA3成為Python筆記本的collaborator\",\n			\"createDate\": \"2024-02-14 16:28:41\",\n			\"inviterName\": \"test\",\n			\"inviterEmail\": \"test@test.com\"\n		},\n	]\n}\n```\n\n##### 更新invitation\npath\n```json\nPUT /api/notebooks/{notebookId}/invitations\n```\nRequest Param\n```\nnone\n```\nPath Variable\n```\nnotebookId: 要update invitation的notebookId\n```\nRequestBody\n```json\n{\n	\"isAccept\": true\n}\n```\nisAccept：required true。\ntoken\n```\ntoken: true\n```\nResponse Body\n```json\n{\n	\"result\": true\n}\n```\n\n###### 開發思路\n思考一下如何完成邀請共編人員的流程。\n1. 前端會發出一個邀請共編人員的邀請，此時`invitation`就會多一個資料，並且等待invitee接受。這時`invitation`表就會執行一次insert。\n2. 當前多invitee案了Allow或Deny，就會發一個`put request`到後端，更新狀態。所以`invitation`就會執行一次update，將此inviteId的`isOpen`和`isAccept`做更新。\n3. 在invitation的Service層中，接收到update的endpoint除了會依照isAccept的更新`invitation`，還要根據更新的notebookId和inviterId, inviteeId更新notebooks_users_role資料表，將invitee變成`collaborator`角色。\n4. 權限的部分，只要是member都可以update invitation，因為沒有透過inivitationId給前端，因此前端只能用userId, notebookId, isPending這三個欄位來更新資料，就沒有安全性的問題。\n\n##### Invitee更新invitation\n**update這邊可以開multi-thread**，記得要加上@Transaction\n`update`的request body需要以下參數：\n1. invitationId\n2. isAccept\n3. inviteeId(從token解析完在set)\n4. notebookId()\n\nMember可以update是因為在成為collaborator之前，都只是member，而提交Accept或Deny都會需要更新invitation，因此需要開放update讓member更新。\n只是在Resource Server的DAO層做update時，**sql就要加上WHERE invitee = :inviteeId，確保是invitee發出的update請求。\n\n\nUpdateRequestPo\n```java\nprivate String inviteeEmail;  //(token解析後set email)\nprivate String notebookId;  //(取得path variable後set notebookId)\nprivate Boolean isAccept; //required = true\n```\n\n#### 刪除Invitation \npath\n```json\nDELETE /api/notebooks/{notebookId}/invitation\n```\nRequest Param\n```\nnone\n```\nPath Variable\n```\nnotebookId: 要刪除invitation的notebookId\n```\nRequestBody\n```json\nnone\n```\ntoken\n```\ntoken: true\n```\nResponse Body\n```json\n{\n	\"result\": true\n}\n```\n只有owner可以刪除invitation。\n```java\nInteger invitationId;\nString notebookId;\nString uesrId;\n```\nuserId一樣在delete API接收到token後，解析出userId在set到po裡面。\n\n### invitation細節說明\n1. 權限說明：\n	在GET sent-Invitation和received-inivitation時，是不指定notebookId的，因為是根據user來判斷有哪些invitation。因此權限驗證也是和GET notebooks一樣，只驗證使用者token，通過即可。\n2. AppConfig：\n	我發現如果api路徑的前綴都有`/api/notebooks/**`開頭的，都會丟兩次驗證請求到Auth Server。後來發現是因為在AppConfig中，Interceptor的設定是一直往下匹配的，比如說`/api/notebooks/{notebookId}/notes`，就會丟兩次驗證請求到Auth，第一次是驗證`/api/notebooks/{notebookId}/notes`，第二次是驗證`/api/notebooks`，因此在`/api/notebooks`需要移除以下路徑，這樣就不會重複發request。\n```java\n.excludePathPatterns(  \n    \"/api/notebooks/*/invitations\",  \n    \"/api/notebooks/*/notes/*/\",  \n    \"/api/notebooks//notes/*/tags/**\",  \n    \"/api/notebooks/*/collaborators\"  \n);\n```\n3. GET Invitation的返回值\n	返回值中並沒有包含InvitationId，因為在Update或delete invitation時，條件可以透過inviteeEmail + notebookId + isOpen(1)，這是一組唯一key，可以用這個來做條件篩選，更新該筆Invitation。\n\n\n### collaborator\n共有兩個API\n- [[API文件 - Resource#取得collaborators|取得collaborators]]\n- [[API文件 - Resource#刪除collaborator|刪除collaborator]]\n\n#### 取得collaborators\npath\n```json\nGET /api/notebooks/{notebookId}/collaborators\n```\nRequest Param\n```\nnone\n```\nPath Variable\n```\nnotebookId: 要取得collabarators的notebookId\n```\nRequestBody\n```json\nnone\n```\ntoken\n```\ntoken: true\n```\nResponse Body\n```json\n{\n	\"collaborators\": [\n		{\n			\"name\": \"a1\",\n			\"userEmail\": \"a1@test.com\"\n		}\n	],\n	\"owner\": {\n		\"ownerName\": \"test\",\n		\"ownerEmail\": \"test@test.com\"\n	}\n}\n```\n\n#### 刪除collaborator\npath\n```json\nDELETE /api/notebooks/{notebookId}/collaborator\n```\nRequest Param\n```\nnone\n```\nPath Variable\n```\nnotebookId: 要刪除collaborator的notebookId\n```\nRequestBody\n```json\nnone\n```\ntoken\n```\ntoken: true\n```\nResponse Body\n```json\n{\n	\"result\": true\n}\n```\n\n#### Tag\n共有六隻API\n- [[API文件 - Resource#新增notebook Tag|新增notebook Tag]]\n- [[API文件 - Resource#新增note tag|新增note tag]]\n- [[API文件 - Resource#取得Notebook Tag|取得Notebook Tag]]\n- [[API文件 - Resource#取得note tag|取得note tag]]\n- [[API文件 - Resource#刪除notebook Tag|刪除notebook Tag]]\n- [[API文件 - Resource#刪除note tag|刪除note tag]]\n\n##### 新增notebook Tag\npath\n```json\nPOST /api/notebooks/{notebookId}/tags\n```\nRequest Param\n```\nnone\n```\nPath Variable\n```\nnotebookId: 要建立tag的notebookId\n```\nRequestBody\n```json\n{\n	\"name\": \"Java Tag Create By test\"\n}\n```\nname：required = true\n\ntoken\n```\ntoken: true\n```\nResponse Body\n```json\n{\n	\"tagId\": \"Tfb483ca8290897c1653b739570e18739\"\n}\n```\n\n##### 新增note tag\npath\n```json\nPOST /api/notebooks/{notebookId}/notes/{noteId}/tags\n```\nRequest Param\n```\nnone\n```\nPath Variable\n```\nnotebookId: 要建立tag的notebookId\nnoteId: 要建立tag的noteId\n```\nRequestBody\n```json\n{\n	\"tagId\": \"T6abd32e83b0054730c888a05a28f539e\"\n}\n```\ntoken\n```\ntoken: true\n```\nResponse Body\n```json\n{\n	\"result\": true\n}\n```\n\n##### 取得Notebook Tag\npath\n```json\nGET /api/notebooks/{notebookId}/tags\n```\nRequest Param\n```\nnone\n```\nPath Variable\n```\nnotebookId: 要取得tag的notebookId\n```\nRequestBody\n```json\nnone\n```\ntoken\n```\ntoken: true\n```\nResponse Body\n```json\n{\n	\"tags\": [\n		{\n			\"tagId\": \"T6abd32e83b0054730c888a05a28f539e\",\n			\"name\": \"Java Tag Create By A1\"\n		},\n		{\n			\"tagId\": \"T29e2b3cb5df68eeed82b3f8114b78bcf\",\n			\"name\": \"Java tag test\"\n		},\n		{\n			\"tagId\": \"TJ1\",\n			\"name\": \"java1\"\n		},\n		{\n			\"tagId\": \"TJ2\",\n			\"name\": \"java2\"\n		},\n		{\n			\"tagId\": \"TJ3\",\n			\"name\": \"java3\"\n		},\n		{\n			\"tagId\": \"TJ4\",\n			\"name\": \"java4\"\n		}\n	]\n}\n```\n\n##### 取得note tag\npath\n```json\nGET /api/notebooks/{notebookId}/notes/{noteId}/tags\n```\nRequest Param\n```\nnone\n```\nPath Variable\n```\nnotebookId: 要取得tag的notebookId\nnoteId: 要取得tag的noteId\n```\nRequestBody\n```json\nnone\n```\ntoken\n```\ntoken: true\n```\nResponse Body\n```json\n{\n	\"tags\": [\n		{\n			\"tagId\": \"T6abd32e83b0054730c888a05a28f539e\",\n			\"name\": \"Java Tag Create By A1\"\n		},\n		{\n			\"tagId\": \"T29e2b3cb5df68eeed82b3f8114b78bcf\",\n			\"name\": \"Java tag test\"\n		},\n		{\n			\"tagId\": \"TJ1\",\n			\"name\": \"java1\"\n		}\n	]\n}\n```\n\n##### 刪除notebook Tag\npath\n```json\nDELETE /api/notebooks/{notebookId}/tags?tagId=T6abd32e83b0054730c888a05a28f539e\n```\nRequest Param\n```\ntagId : 想刪除的tagId\n```\nPath Variable\n```\nnotebookId: 要刪除tag的notebookId\n```\nRequestBody\n```json\nnone\n```\ntoken\n```\ntoken: true\n```\nResponse Body\n```json\n{\n	\"result\": true\n}\n```\n\n##### 刪除note tag\npath\n```json\nDELETE /api/notebooks/{notebookId}/notes/{noteId}/tagstagId=T29e2b3cb5df68eeed82b3f8114\n```\nRequest Param\n```\ntagId : 想刪除的tagId\n```\nPath Variable\n```\nnotebookId: 要刪除tag的notebookId\nnoteId: 要刪除tag的noteId\n```\nRequestBody\n```json\nnone\n```\ntoken\n```\ntoken: true\n```\nResponse Body\n```json\n{\n	\"result\": true\n}\n```\n\n\n\n\n### 待辦清單\n- [x] get collaborator service要再加上一個get owner，並且返回到json中。\n目前是這樣：\n```json\n{\n	\"collaborators\": [\n		{\n			\"name\": \"a1\",\n			\"userEmail\": \"a1@test.com\"\n		}\n	],\n	\"owner\": {\n		\"name\": \"Joey\",\n		\"email\": \"joey.liao@gmail.com\"\n	}\n}\n```\n- [x] GET note需要返回note擁有的tags\n- [x] GET notebook時有哪些tag一起返回。\n\n\n',NULL,'2024-03-12 09:08:41',1,'NB42801eed039177f8620d4c63b3f8acb5');
/*!40000 ALTER TABLE `notes` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `notes_tags`
--

DROP TABLE IF EXISTS `notes_tags`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `notes_tags` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `noteId` varchar(33) NOT NULL,
  `tagId` varchar(33) NOT NULL,
  PRIMARY KEY (`tagId`,`noteId`),
  UNIQUE KEY `id` (`id`),
  KEY `noteId` (`noteId`),
  CONSTRAINT `notes_tags_ibfk_1` FOREIGN KEY (`noteId`) REFERENCES `notes` (`id`) ON DELETE CASCADE,
  CONSTRAINT `notes_tags_ibfk_2` FOREIGN KEY (`tagId`) REFERENCES `tags` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=56 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `notes_tags`
--

LOCK TABLES `notes_tags` WRITE;
/*!40000 ALTER TABLE `notes_tags` DISABLE KEYS */;
INSERT INTO `notes_tags` VALUES (9,'Nf47cbd6f59d0b680b9062c745f760747','Te02f576f4d8c2567a6007a43f0ab1118'),(10,'Nf47cbd6f59d0b680b9062c745f760747','Td382923ce4324559f5acc8b204a12234'),(11,'N5ace17699f90f2bca2b4b2966bb089e6','T61ad864c7df26a2bb7af43595d0ecd3d'),(12,'N5ace17699f90f2bca2b4b2966bb089e6','T2172eb58fa6222756957624ac3a39532'),(13,'N5ace17699f90f2bca2b4b2966bb089e6','T0c9cd6a7b83336ab3d4ac7a0770eba86'),(14,'Ne50c310146ff2d62d8a555afc6182528','T2172eb58fa6222756957624ac3a39532'),(15,'N60a8bbfa2ba29152b29bdda57586d2df','T2172eb58fa6222756957624ac3a39532'),(16,'N0b85358b3389c7c9ac0493684d9f8b87','T2172eb58fa6222756957624ac3a39532'),(17,'N59d395b26a9458a2ec0139a5cb44e8a6','T2172eb58fa6222756957624ac3a39532'),(18,'N92bfab7d8f38c6981d6ddc1fa2218de6','T2172eb58fa6222756957624ac3a39532'),(20,'N594ecafac0ce152eba602b68219d9cec','T61ad864c7df26a2bb7af43595d0ecd3d'),(21,'N594ecafac0ce152eba602b68219d9cec','T2172eb58fa6222756957624ac3a39532'),(22,'N15357547b663b71456b227939348c4b3','Td16d2aa3762bc975a669c7f708ce7919'),(23,'N15357547b663b71456b227939348c4b3','T2172eb58fa6222756957624ac3a39532'),(24,'Ncae74ed6e1cd927f7610879fe726945c','T2172eb58fa6222756957624ac3a39532'),(25,'N6272f2e986a0007b4bd4c06d49e510bd','T2172eb58fa6222756957624ac3a39532'),(26,'N653c7b8c66db2512042b91bb2312e975','T2172eb58fa6222756957624ac3a39532'),(27,'N88abb12d00fbf52ed7b13803c3334c71','T2172eb58fa6222756957624ac3a39532'),(28,'Na790b044432a613ef1fb17bef6adbeaf','T6037f327b6495880dee2389925aea51c'),(29,'Na790b044432a613ef1fb17bef6adbeaf','T2172eb58fa6222756957624ac3a39532'),(30,'N88abb12d00fbf52ed7b13803c3334c71','T6037f327b6495880dee2389925aea51c'),(31,'N88abb12d00fbf52ed7b13803c3334c71','T61ad864c7df26a2bb7af43595d0ecd3d'),(32,'N653c7b8c66db2512042b91bb2312e975','T61ad864c7df26a2bb7af43595d0ecd3d'),(33,'N6272f2e986a0007b4bd4c06d49e510bd','T61ad864c7df26a2bb7af43595d0ecd3d'),(34,'N9976163068601145872c604c6eb4da1e','T2172eb58fa6222756957624ac3a39532'),(35,'N9976163068601145872c604c6eb4da1e','T6037f327b6495880dee2389925aea51c'),(36,'N1ff01fd502ed41cad3e68b790f751feb','T2172eb58fa6222756957624ac3a39532'),(37,'N1ff01fd502ed41cad3e68b790f751feb','T6037f327b6495880dee2389925aea51c'),(38,'Nb825ecfc04a4d7195737a33150e293f9','T2172eb58fa6222756957624ac3a39532'),(39,'Nb825ecfc04a4d7195737a33150e293f9','T6037f327b6495880dee2389925aea51c'),(40,'Nae6f6e5cf9d8653ee2491c6f0cc5e963','T2172eb58fa6222756957624ac3a39532'),(41,'Nae6f6e5cf9d8653ee2491c6f0cc5e963','T7adca8f6ee44e28a86ae9479b0fa2017'),(42,'Nae6f6e5cf9d8653ee2491c6f0cc5e963','T61ad864c7df26a2bb7af43595d0ecd3d'),(43,'Nae6f6e5cf9d8653ee2491c6f0cc5e963','T6037f327b6495880dee2389925aea51c'),(45,'N1244bcf426b7c20fde969c7fbb4495a7','Tfa134a0928934f9bb093d1dc9d6fd00e'),(46,'N1244bcf426b7c20fde969c7fbb4495a7','T02fdc8243a1b200698c7226cc782c419'),(47,'N058d42db63d709a872f6969655252694','Tf8f65c37338cde20b36ed0446f436d31'),(48,'N058d42db63d709a872f6969655252694','Tfa134a0928934f9bb093d1dc9d6fd00e'),(49,'N7bbd4f2ed3f66eaf90c2ff1bb8cd5191','Tf8f65c37338cde20b36ed0446f436d31'),(50,'N7bbd4f2ed3f66eaf90c2ff1bb8cd5191','Tfa134a0928934f9bb093d1dc9d6fd00e'),(51,'N47b2fc5df4ff934db8aa15cb45f73fd8','Tf8f65c37338cde20b36ed0446f436d31'),(52,'N47b2fc5df4ff934db8aa15cb45f73fd8','Tfa134a0928934f9bb093d1dc9d6fd00e'),(53,'Nae8920d3849b62e7aa878944c7a83b44','Tf8f65c37338cde20b36ed0446f436d31'),(54,'Nae8920d3849b62e7aa878944c7a83b44','Tfa134a0928934f9bb093d1dc9d6fd00e'),(55,'N2471e896a68756d1a6ec59249f6de5a4','T32d2beaf5e9922a96f1fc042b73a4689');
/*!40000 ALTER TABLE `notes_tags` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `role`
--

DROP TABLE IF EXISTS `role`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `role` (
  `id` tinyint NOT NULL AUTO_INCREMENT,
  `name` varchar(50) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `name` (`name`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `role`
--

LOCK TABLES `role` WRITE;
/*!40000 ALTER TABLE `role` DISABLE KEYS */;
INSERT INTO `role` VALUES (2,'ROLE_COLLABORATOR'),(4,'ROLE_GUEST'),(3,'ROLE_MEMBER'),(1,'ROLE_OWNER');
/*!40000 ALTER TABLE `role` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `role_permission`
--

DROP TABLE IF EXISTS `role_permission`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `role_permission` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `roleId` tinyint NOT NULL,
  `target` tinyint NOT NULL,
  `behaviorId` tinyint NOT NULL,
  `actionId` tinyint NOT NULL,
  UNIQUE KEY `id` (`id`),
  KEY `actionId` (`actionId`),
  KEY `target` (`target`),
  KEY `index_role` (`roleId`),
  CONSTRAINT `role_permission_ibfk_1` FOREIGN KEY (`roleId`) REFERENCES `role` (`id`),
  CONSTRAINT `role_permission_ibfk_2` FOREIGN KEY (`actionId`) REFERENCES `action` (`id`),
  CONSTRAINT `role_permission_ibfk_3` FOREIGN KEY (`target`) REFERENCES `target` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=81 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `role_permission`
--

LOCK TABLES `role_permission` WRITE;
/*!40000 ALTER TABLE `role_permission` DISABLE KEYS */;
INSERT INTO `role_permission` VALUES (1,1,1,1,1),(2,1,1,2,1),(3,1,1,3,1),(4,1,1,4,1),(5,1,2,1,1),(6,1,2,2,1),(7,1,2,3,1),(8,1,2,4,1),(9,1,3,1,1),(10,1,3,2,1),(11,1,3,3,1),(12,1,3,4,1),(13,1,4,1,1),(14,1,4,2,1),(15,1,4,3,1),(16,1,4,4,1),(17,1,5,1,1),(18,1,5,2,1),(19,1,5,3,1),(20,1,5,4,1),(21,2,1,1,2),(22,2,1,2,1),(23,2,1,3,2),(24,2,1,4,2),(25,2,2,1,1),(26,2,2,2,1),(27,2,2,3,1),(28,2,2,4,1),(29,2,3,1,1),(30,2,3,2,1),(31,2,3,3,1),(32,2,3,4,1),(33,2,4,1,2),(34,2,4,2,1),(35,2,4,3,2),(36,2,4,4,2),(37,2,5,1,2),(38,2,5,2,2),(39,2,5,3,2),(40,2,5,4,2),(41,3,1,1,2),(42,3,1,2,2),(43,3,1,3,2),(44,3,1,4,2),(45,3,2,1,2),(46,3,2,2,2),(47,3,2,3,2),(48,3,2,4,2),(49,3,3,1,2),(50,3,3,2,2),(51,3,3,3,2),(52,3,3,4,2),(53,3,4,1,2),(54,3,4,2,2),(55,3,4,3,2),(56,3,4,4,2),(57,3,5,1,2),(58,3,5,2,2),(59,3,5,3,1),(60,3,5,4,2),(61,4,1,1,2),(62,4,1,2,2),(63,4,1,3,2),(64,4,1,4,2),(65,4,2,1,2),(66,4,2,2,2),(67,4,2,3,2),(68,4,2,4,2),(69,4,3,1,2),(70,4,3,2,2),(71,4,3,3,2),(72,4,3,4,2),(73,4,4,1,2),(74,4,4,2,2),(75,4,4,3,2),(76,4,4,4,2),(77,4,5,1,2),(78,4,5,2,2),(79,4,5,3,2),(80,4,5,4,2);
/*!40000 ALTER TABLE `role_permission` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tags`
--

DROP TABLE IF EXISTS `tags`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tags` (
  `id` varchar(33) NOT NULL,
  `name` varchar(50) NOT NULL,
  `notebookId` varchar(34) NOT NULL,
  PRIMARY KEY (`name`,`notebookId`),
  UNIQUE KEY `id` (`id`),
  KEY `index_name` (`name`),
  KEY `index_notebookId` (`notebookId`),
  CONSTRAINT `tags_ibfk_1` FOREIGN KEY (`notebookId`) REFERENCES `notebooks` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tags`
--

LOCK TABLES `tags` WRITE;
/*!40000 ALTER TABLE `tags` DISABLE KEYS */;
INSERT INTO `tags` VALUES ('T02fdc8243a1b200698c7226cc782c419','Sprgin boot','NB141dbe225717cac24196d99b9ebf77b4'),('T0c9cd6a7b83336ab3d4ac7a0770eba86','Design','NBcb38e3739df86de4b7af6edb9821257d'),('T2172eb58fa6222756957624ac3a39532','開發歷程','NBcb38e3739df86de4b7af6edb9821257d'),('T32d2beaf5e9922a96f1fc042b73a4689','指令','NB896b68f9bacfc4f4a9cb3c2e349119f7'),('T6037f327b6495880dee2389925aea51c','FrontEnd','NBcb38e3739df86de4b7af6edb9821257d'),('T61ad864c7df26a2bb7af43595d0ecd3d','BackEnd','NBcb38e3739df86de4b7af6edb9821257d'),('T7adca8f6ee44e28a86ae9479b0fa2017','DevOps','NBcb38e3739df86de4b7af6edb9821257d'),('Td16d2aa3762bc975a669c7f708ce7919','AWS','NBcb38e3739df86de4b7af6edb9821257d'),('Td382923ce4324559f5acc8b204a12234','CODE','NB6bb61275bffb47586a57f94ca21f88a8'),('Te02f576f4d8c2567a6007a43f0ab1118','使用教學','NB6bb61275bffb47586a57f94ca21f88a8'),('Tf7ce14944f0c8b2171f54426bc8d004d','Backend','NB141dbe225717cac24196d99b9ebf77b4'),('Tf8f65c37338cde20b36ed0446f436d31','Spring','NB141dbe225717cac24196d99b9ebf77b4'),('Tfa134a0928934f9bb093d1dc9d6fd00e','Java','NB141dbe225717cac24196d99b9ebf77b4');
/*!40000 ALTER TABLE `tags` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `target`
--

DROP TABLE IF EXISTS `target`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `target` (
  `id` tinyint NOT NULL AUTO_INCREMENT,
  `name` varchar(50) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `name` (`name`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `target`
--

LOCK TABLES `target` WRITE;
/*!40000 ALTER TABLE `target` DISABLE KEYS */;
INSERT INTO `target` VALUES (4,'COLLABORATOR'),(5,'INVITATION'),(2,'NOTE'),(1,'NOTEBOOK'),(3,'TAG');
/*!40000 ALTER TABLE `target` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `users`
--

DROP TABLE IF EXISTS `users`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `users` (
  `id` varchar(36) NOT NULL,
  `username` varchar(50) NOT NULL,
  `email` varchar(50) NOT NULL,
  `password` varchar(32) NOT NULL,
  `status` tinyint(1) NOT NULL DEFAULT '1',
  `create_date` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `last_modified_date` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `email` (`email`),
  KEY `index_name` (`email`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `users`
--

LOCK TABLES `users` WRITE;
/*!40000 ALTER TABLE `users` DISABLE KEYS */;
INSERT INTO `users` VALUES ('28341e74-b012-48ea-9d2f-51c1887a9fd0','mandy','mandy@test.com','47bce5c74f589f4867dbd57e9ca9f808',1,'2024-03-11 01:39:46','2024-03-11 01:39:46'),('4336f9d6-e86a-4f15-8fe9-648e22cada83','katlyn','katlyn@test.com','e10adc3949ba59abbe56e057f20f883e',1,'2024-03-11 06:17:27','2024-03-11 06:17:27'),('483d4c98-08a2-47c8-90af-51b7c6a7086d','Joey Liao','joey.liao@test.com','e99a18c428cb38d5f260853678922e03',1,'2024-03-11 06:22:33','2024-03-11 06:22:33'),('5a1cf03c-bf53-476e-9840-60af15e0af6a','aaa','aaa@test.com','47bce5c74f589f4867dbd57e9ca9f808',1,'2024-03-11 01:43:22','2024-03-11 01:43:22'),('d9b0b25c-49d9-42b2-8865-98a4937fd26e','test1','test1@test.com','c4ca4238a0b923820dcc509a6f75849b',1,'2024-04-18 02:46:47','2024-04-18 02:46:47'),('f436d5f6-b750-41a3-a88a-d7f7d47612f9','joey01271998','joey01271998@gmail.com','9d656c6b950160fe93c9d7cbbc7be9ce',1,'2024-08-06 08:46:46','2024-08-06 08:46:46'),('userA1','a1','a1@test.com','e99a18c428cb38d5f260853678922e03',1,'2024-03-09 12:50:22','2024-03-09 12:50:22'),('userA2','a2','a2@test.com','e99a18c428cb38d5f260853678922e03',1,'2024-03-09 12:50:22','2024-03-09 12:50:22'),('userA3','a3','a3@test.com','e99a18c428cb38d5f260853678922e03',1,'2024-03-09 12:50:22','2024-03-09 12:50:22'),('userTest','test','test@test.com','e99a18c428cb38d5f260853678922e03',1,'2024-03-09 12:50:22','2024-03-09 12:50:22');
/*!40000 ALTER TABLE `users` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2024-08-11 22:58:24
